text
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- ABSTRACTThe Common Weakness Enumeration (CWE) community publishes an aggregate metric to calculatethe 'Most Dangerous Software Errors.' However, the used equation highly biases frequency overexploitability and impact. We provide a metric to mitigate this bias and discuss the most significantsoftware weaknesses over the last ten years."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- IntroductionIn 2020, there were over 18 000 documented software vulnerabilities that enable malicious activity. While manyare discovered, they map to a relatively small set of underlying weakness types. We posit that if the most significant of these types can be identified, developers of programming languages, software, and security tools can focus on preventing them and thus, over time, diminish the quantity and severity of newly discovered vulnerabilities. We define a 'significant' weakness as one that is both frequently occurring among the set of publicly published vulnerabilities and results in high severity vulnerabilities (those that are easily exploitable and have high impact). The set of security weakness types upon which we calculate significance comes from the Common Weakness Enumeration (CWE)."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- IntroductionIn the fall of 2019, the CWE community published an equation to calculate the ""Top 25 Most Dangerous SoftwareErrors"" (MDSE) among the set of CWEs. It follows the form of the standard security risk matrix combiningprobability/frequency and severity."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- IntroductionThe MDSE equation claims to combine 'the frequency that a CWE is the root cause of a vulnerability with theprojected severity'; the equation description implies that both factors are weighed equally (making no mention of any bias). However, we empirically found that the equation highly biases frequency and almost ignores severity in generating top lists of varying sizes. This is due to the equation multiplying calculated frequency and severity values together though each has very different distributions. Frequency distributions have a power-law like curve, while severity distributions are more uniform. Our mitigation is to create a revised equation, named MSSW, that adjusts the frequency distribution using a double log function to better match it to the severity distribution."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Cybersecurity vulnerabilitiesWe can define a vulnerability as a weakness, in the security of a system, that can be exploited. The Common Vulnerabilities and Exposures (CVE) is a large set of publicly disclosed vulnerabilities in widely-used software. They are enumerated with a unique identifier, described, and referenced with external advisories."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Cybersecurity vulnerabilities Scoring vulnerabilities severityThe Common Vulnerability Scoring System (CVSS) 'provides a way to capture the principal characteristics of avulnerability and produce a numerical score reflecting its severity'. The CVSS base score takes into account the exploitability (how easy it is to use the vulnerability in an attack) and impact (how much damage the vulnerability can cause to an affected component) of a vulnerability apart from any specific environment.The exploitability score is determined by the following: attack vector: 'the context by which vulnerability exploitation is possible', attack complexity: 'the conditions beyond the attacker's control that must exist in order to exploit the vulnerability', privileges required: 'the level of privileges an attacker must possess before successfully exploiting the vulnerability', and user interaction: a human victim must participate for the vulnerability to be exploited."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Cybersecurity vulnerabilities Scoring vulnerabilities severityThe impact score is determined by measuring the impact to the confidentiality, integrity, and availability of the affectedsystem. Also included is a scope metric that 'captures whether a vulnerability in one vulnerable component impactsresources in components beyond its security scope'."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Cybersecurity vulnerabilities Weaknesses: Classifying vulnerabilitiesWhile we define a vulnerability in terms of a weakness, it is hard to define a weakness itself. As different vulnerabilities may be associated with the same weakness type, we could look at a weakness type as a class and a vulnerability as an instance of that class. Although it is uncommon, a single vulnerability could be associated with two or more weaknesses exploited sequentially or in parallel. In that sense, a vulnerability is a set with one or more instances of weaknesses."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Cybersecurity vulnerabilities Weaknesses: Classifying vulnerabilitiesThe Common Weakness Enumeration (CWE) is a 'community-developed list of common software security weaknesses'. It contains an enumeration, descriptions, and references for 839 software weaknesses that are referred to as CWEs, where each is labelled CWE-X with X being an integer."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Cybersecurity vulnerabilities Weaknesses: Classifying vulnerabilitiesThe CWE weaknesses model has four layers of abstraction: pillar, class, base, and variant. There is also the notion of a compound, that associates two or more interacting or co-occurring CWEs. These abstractions reflect to what extent issues are described in terms of five dimensions: behavior, property, technology, language, and resource. Variant weaknesses are at the most specific level of abstraction; they describe at least three dimensions. Base weaknesses are more abstract than variants and more specific than classes; they describe two to three dimensions. Class weaknesses are very abstract; they describe one to two dimensions, typically not specific about any language or technology. Pillar weaknesses are the highest level of abstraction."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Cybersecurity vulnerabilities Weaknesses: Classifying vulnerabilitiesThere are a set of taxonomies, called views, to help organize the CWEs. Two prominent CWE taxonomies are the'Research Concepts' (view 1000) and 'Development Concepts'. There is also the 'CWE Weaknesses forSimplified Mapping of Published Vulnerabilities View' that was made to describe the set of CVEs; it contains 127 CWEs."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Cybersecurity vulnerabilities Binding CVEs, CWEs, and CVSSThe National Vulnerability Database (NVD) offers a public database that maps all CVE entries to CWEs and CVSS scores. For each CVE it provides a CVSS score along with the applicable CWE(s) that describe the weakness(es) enabling the vulnerability. The NVD data is the cornerstone of this work, enabling the analysis of the most significant CWEs over the last ten years."
A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MDSE scoreThe MDSE equation was designed to balance the frequency and severity in ranking the CWEs. The frequency isdetermined by the number of CVEs that map to a given CWE in the time period of study. The severity is determined by the mean CVSS score for the CVEs mapped to a given CWE. The MDSE score for a CWE is produced by multiplying the normalized frequency by the normalized severity and then multiplying by 100.
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MDSE score Limitation 1: Distribution DifferencesThe MDSE score then appears to equally include both frequency and severity. However, we empirically find that the MDSE equation strongly biases frequency over severity. The MDSE equation in practice biases frequency over severity, even though its equation treats them equally, because frequency and severity have very different distributions. This can be illustrated by the analysis of 2019. The frequency distribution has the majority of CWEs at a very low frequency and a few at a very high frequency (somewhat resembling a power law curve).The severity distribution is more uniform within a limited range."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MDSE score  Limitation 2: Normalization Error The normalization of the CVSS score does not lead to the expected and desired normalized distribution from 0 to 1. For our data the range is from .28 to .97. The reason for this is that the mean of the CVSS score for the CVEs that map to a particular CWE has a smaller range than the maximum and minimum CVSS score. This limitation, while of less consequence than the previous, constrains the range of Si values thus further lessening the influence that severity has in determining a MDSE score."
A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MSSW scoreOur goal is to mitigate the limitations of the MDSE equation.
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MSSW score  Addressing the MDSE's limitationsTo address MDSE limitation 1, we propose a linearization for the normalized frequency. This proposal represent a behavior which create large differences between the most frequent CWEs and almost no difference between the infrequent CWEs.'"
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MSSW score  Addressing the MDSE's limitationsThus, we apply a double log for further linearization. We note that this approach is not pseudo-linear for the most infrequent of CWEs. However, this does not cause problems as our goal is to identify the most significant and any such CWE must have at least a moderate frequency."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MSSW score  Addressing the MDSE's limitationsThe MSSW equation then multiplies frequency and severity as in the original MDSE equation. However, it multiplies from two distributions with a similar shape for the part of the functions that are of interest. This enables the MSSW equation to more fairly balance frequency and severity in scoring and ranking a CWE."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MSSW score  Addressing the MDSE's limitationsTo address MDSE limitation 2, the MSSW normalizes the severity using the maximum and minimum mean severityvalues. This gives the distribution a full 0 to 1 range, which is not achieved in the MDSE equation."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MSSW score  Analyzing the MSSWWe evaluate the effect of the MSSW equation in making the frequency and severity distributions more similar, producing a score with more equal inclusion of both frequency and severity."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MSSW score  Analyzing the MSSWNoticeable is how the MSSW equation chooses CWEs for the top 20 list from CWEs with generally higher CVSS scores. However, it excludes many high severity CWEs because their frequencies were too low."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MSSW score  Analyzing the MSSWNote that our usage of the double log reflects the nature of the data (observed frequencies) and the desire to fairly balance evaluating frequency and severity in the MDSE equation. If the frequencies had created a different distribution, another ""linearization"" function would potentially have been better justified. Our main finding is that the MDSE will likely be (and currently is) biased toward one of the parameters (frequency or severity) depending on their relative distributions."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical AnalysisWe use our improved scoring equation (MSSW) to perform a historical study of the most significant weaknesses over the ten-year period of 2011 to 2020. To do so, we collected the 10 CWEs with the highest MSSW value for each year and ranked them in descending order. Our analysis of these lists informs us about the evolution of the software weaknesses landscape so that we can determine if it is changing or static. Our finding is that a similar set of CWEs occupy the Top 10 lists each year and those CWEs can be grouped into an even smaller set of weakness types. "
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical AnalysisIt can be observed that this indicates the weaknesses landscape has been dominated by only a few weakness types; it is due to the same CWEs occurring in the Top 10 lists each year. Among the 88 possible BVC CWEs, only 19 have appeared in the Top 10 lists for the last 10 years (11 of which have appeared at least 5 times). Similarly, among the 39 possible PC CWEs, only 17 have appeared in the Top 10 lists for the same period (9 of which have appeared at least 5 times). These results show that a minority subset of CWEs have dominated the Top 10 lists for the last decade; from this vantage point the software weaknesses landscape is practically not changing. Instead of seeing a diversity of CWEs entering the Top 10 lists, the same kinds of weaknesses reappear year after year."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical AnalysisTwo groups of weaknesses dominate the Top 10 lists: injection and memory errors.These include CWEs that are related to file management, data authenticity, authentication, and integer arithmetic which we have put in one group, 'Other CWEs'."
A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical AnalysisOne can observe that a consistent increase in the sum of the MSSW scores of all Top 10 BVC CWEs duringthe last ten years. This represents a shift where a subset of CWEs increasingly become both the most frequent and impactful. Note that this is not due to simply an increase in the number of vulnerabilities discovered because both frequency and impact are normalized within MSSW. One explanation for this trend could simply be that attackers are increasingly leveraging CWEs that give them the greatest influence on targeted systems.
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical AnalysisInjection and memory corruption CWEs follow this trend of increasing MSSW scores and they dominate the Top 10lists. We can observe that after 2017, all the five most dangerous CWEs are either injection or memory corruption. After 2019, only 2 CWEs are outside of those groups in the BVC Top 10 lists. This explains the increase of the MSSW score sum for injection and memory corruption CWEs and the decrease of the MSSW score sum for other CWEs."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical Analysis Injection and Memory Corruption: The Most Dangerous WeaknessesWe now look more closely at these 2 top CWE groupings. An injection bug happens when an unsanitized input isassembled, added, or inserted in a code fragment or in a command, forming an invalid construct that is not supposed to be executed. "
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical Analysis Injection and Memory Corruption: The Most Dangerous WeaknessesThe three most dangerous CWEs form the MSSW Top 10 Base/Variant/Component: CWE-89, CWE-78, and CWE-94. Theyall appear with very high MSSW scores every year. SQL Injection is by far the most dangerous weakness in ouranalysis. It is consistently the number one weakness in every Top 10 BVC list, with an average MSSW score of 76.6. It contributes to the class CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component). OS Command Injection is the second most dangerous injection weakness. It appears in every Top 10 BVC list except for 2011 and 2016, with an average MSSW score of 75.18. It is also a contributor to CWE-74 and a contributor to CWE-77 (Improper Neutralization of Special Elements used in a Command ('Command Injection'). Code Injection appears in every Top 10 BVC list except 2012, 2014, and 2017, with an average MSSW score of 66.9. It is also a contributor to CWE-74 and a contributor to CWE-913 (Improper Control of Dynamically-Managed Code Resources). Interestingly, CWE-74 has a light grey circle in The MSSW Top 10 Pillar/Class, while its children base CWE-89, 78, and 94 have very dark ovals in MSSW Top 10 Base/Variant/Component. This happens because CWE-74 is also parent of several CWEs that are either very infrequent or nonsevere."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical Analysis Injection and Memory Corruption: The Most Dangerous WeaknessesDeserialization of untrusted data (CWE-502) is a considerably new injection weakness. It appears in the BVC Top 10 list in all years after 2016 with a high average MSSW score of 72.6. The exploitation of deserialization bugs was leveraged after November 2015, when Foxglove Security published their exploits for the Java deserialization weakness."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical Analysis Injection and Memory Corruption: The Most Dangerous WeaknessesA memory corruption bug happens when data stored in memory is unintentionally modified. This could happen during memory allocation, deallocation, and use (read and write data). In The MSSW Top 10 Base/Variant/Component, the memory corruption weaknesses are CWE-787 (Out-of-bounds Write), CWE-120 (Classic Buffer Overflow), CWE-416 (Use After Free), and CWE-476 (NULL Pointer Dereference). Out-of-bounds Write is the most dangerous memory corruption weakness. It appears in every Top 10 BVC list except for 2011 and 2015, with an average MSSW score of 70.8. The class CWE-119 is a general memory corruption weakness, which includes use after free and double free. All memory CWEs on the Top 10 lists contribute to the class CWE-119, except CWE-476, contributing to CWE-672. Due to its broad scope, CWE-672 is also the parent of CWE-613."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical Analysis Injection and Memory Corruption: The Most Dangerous WeaknessesSQL Injection and OS Command injection weaknesses have a higher average MSSW score than that of any otherweaknesses. The related CVEs analysis confirms that the injection CVEs are easier to exploit and have a higherimpact. An injection directly leads to arbitrary command, code, or script execution. Once a SQL injection is in place, there is no need of an additional sophisticated attack crafting or use of glitches in the system. In contrast, it takes considerable extra effort for an attacker to turn a buffer overflow into an arbitrary code execution. The possible damage from a SQL injection is also very high. It may expose vast amounts of structured data, which is generally more valuable than raw data. Well-formed structured data is easy to read, sort, search, and make sense of. An attacker could modify a database - insert data, update data, delete data, execute admin operations, recover file content, and even issue OS commands to the operating system."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical Analysis Mapping DependenciesOur historical analysis heavily depends on how NVD assigns CWEs to particular CVEs and it is not always possible for this mapping to be done perfectly. The CWE selection is restricted to view CWE-1003. The lack of enough information about a CVE or the lack of a more specific CWE may lead to the CVE described with the closest class CWE or even with a pillar CWE. For example, it makes sense for class CWE-119 to be used for the memory corruption CVE-2019-7098, as there is not much information, no code nor details about it - it could be any memory use error or a double free. However, there is enough information about the use after free CVE-2019-15554, and it still gets described with class CWE-119, as there is no appropriate base CWE. A close base CWE is CWE-416 (Use After Free), but it does not really reflect memory-safe languages like Rust. It is also possible for a class CWE to be assigned to a CVE even when a specific base CWE is available. For example, the stack buffer overflow write CVE-2019-14363 is assigned class CWE-119, although there is plenty of information and appropriate bases CWE-121 and CWE-120."
A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- No Ground TruthThe constant need to improve information security has motivated a widespread interest in metrics. As Lord Kelvin's famous quote suggests: you cannot improve if you cannot measure.
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- No Ground TruthIn hard sciences, such as physics and chemistry, a measurement is an experimental procedure that compares a quantity against a well-defined standard. A measurement must be reproducible, allowing results comparison over different conditions, such as using different measuring systems. It allows the claim that a measurement result is wrong by showing that it disagrees with other measurements (i.e., irreproducible)."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- No Ground TruthIn software security, we lack not only experimental procedures and stable standards. We are in a much earlier stage of science, where we struggle to agree on the quantities to measure. There are members of the software security community who doubt that security can be measured. They argue that software security metrics may be infeasible, be difficult to validate, not be justified with empirical data, and contain formal treatments adopted from other fields that don't map well to operational security."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- No Ground TruthWe understand that, at least for now, there is no ground truth, and the science of security is still in its early days.However, we posit that acceptable but possibly imperfect metrics must be developed in order to facilitate security decisions and to evaluate changes in security posture. To this end, there have been substantial efforts to produce security metrics; surveys the literature of security metrics published between 1981 and 2008. Specific to software security, there is the OWASP Top 10 for web applications. Also, the CWE project has the Common Weaknesses Scoring System (CWSS) and the Common Weakness Risk Analysis Framework (CWRAF), which are used together to provide the most important weaknesses tailored to a particular organization."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- No Ground TruthGiven that there is no ground truth upon which to justify how to best combine frequency and severity or to establish the CVSS metric's correctness, it is likely impossible to prove any such metric as maximally effective. We make our 'most accurate measurement yet' claim based on the demonstrated limitations in the published MDSE equation and a lack of competing published alternatives. Along with much other work, we believe that our contribution is significant. It points out a severe bias in the CWE MDSE equation that prevents accurate measurements of the most significant software security weaknesses."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- ConclusionSecurity metrics are a challenging scientific research area, because there is often no ground truth, unlike physics and chemistry. This may lead one to focus on just taking simple low-level measurements that are inherently defensible; that was the approach taken in. However, creating aggregate metrics that compose multiple simple measurements is of practical importance for the field of security. In this work, we did just that, aggregating frequency and severity (i.e., exploitability and impact) into a single metric. Our objective was not for the correlations to necessarily be equal, but that there is a strong correlation for both factors that more evenly balance the inclusion of the top frequency and top severity CWEs."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- ConclusionUsing the proposed equation we explore the software weaknesses landscape. We observed that in 10 years, the same types of weaknesses have been dominating the threat landscape and not much has changed. Through the lens of the metrics in this paper we aren't making progress. We believe that the security community needs new approaches. We would prefer not to write this same paper 10 years from now showing that, once again, not much has changed."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- ConclusionIt is challenging to catch up with hackers; they need to find only one weak spot, while we (the community) have to defend entire systems. New doors also get opened (e.g., in recent years Object Deserialization injection). Nevertheless, the results of this study show that either we are incapable of correcting the most common software flaws, or we are focusing on the wrong ones. Although this paper is not making a definite conclusion, the comparison with the historical analysis based on the biased MDSE suggests that it is rather the latter. In either case, it seems to us that there is a need to ""stop and think"" about the ways we are developing software and/or the methods we use to describe and identify vulnerabilities. A new unambiguous classification of software weaknesses that allows clear structured descriptions of security vulnerabilities would be a first step. That would allow formalization and automatization of weaknesses identification and vulnerabilities mitigation. Operationally, more software development languages and tools need to be developed and/or promoted that automatically prevent or remediate commonly identified software weakness."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- AcknowledgmentThis work was partially accomplished under NIST Cooperative Agreement No.70NANB19H063 with PrometheusComputing, LLC. The authors would like to thank the NVD staff for their review and consideration of this work."
"Classifying Memory Bugs Using Bugs Framework Approach- ABSTRACT In this work, we present an orthogonal classification of memory corruption bugs, allowing precise structureddescriptions of related software vulnerabilities. The CommonWeakness Enumeration (CWE) is a well-known and used list ofsoftware weaknesses. However, it's exhaustive list approach isprone to gaps and overlaps in coverage. Instead, we utilize theBugs Framework (BF) approach to define language-independentclasses that cover all possible kinds of memory corruptionbugs. Each class is a taxonomic category of a weakness type,defined by sets of operations, cause/consequence relations,and attributes. A BF description of a bug or a weaknessis an instance of a taxonomic BF class, with one operation,one cause, one consequence, and their attributes. Any memoryvulnerability then can be described as a chain of such instancesand their consequence-cause transitions. We showcase that BFis a classification system that extends the CWE, providing astructured way to precisely describe real world vulnerabilities. Itallows clear communication about software bugs and weaknessesand can help identify exploit mitigation techniques.Keywords are Bug classification, bug taxonomy, software vulnerability, software weakness, memory corruption."
"Classifying Memory Bugs Using Bugs Framework ApproachIn this paper, we first summarize the latest BF approachand methodology. Next, we analyze the types of memorycorruption bugs and define the BF Memory Bugs Model.Then, we present our BF memory bugs classes and showcasethey provide a better, structured way to describe CVE entries. We identify the corresponding clusters of memory corruption CWEs and their relations to the BF classes. Finally,we discuss the use of these new BF classes for identifyingexploit mitigation techniques."
"Classifying Memory Bugs Using Bugs Framework Approach- I. INTRODUCTIONSoftware bugs in memory allocation, use, and deallocation may lead to memory corruption and memory disclosure,opening doors for cyberattacks. Classifying them would allowprecise communication and help us teach about them, understand and identify them, and avoid security failures. For that,we utilize the Bug Framework (BF) approach ."
"Classifying Memory Bugs Using Bugs Framework Approach- I. INTRODUCTIONThe Common Weakness Enumeration (CWE) and theCommon Vulnerabilities and Exposures (CVE) are wellknown and used lists of software security weaknesses andvulnerabilities. However, the CWE's exhaustive list approachis prone to having gaps and overlaps in coverage, as demonstrated by the National Vulnerability Database (NVD) effortto link CVEs to appropriate CWEs . Instead, we utilize theBF approach to define four language-independent, orthogonalclasses that cover all possible kinds of memory relatedsoftware bugs and weaknesses: Memory Allocation Bugs(MAL), Memory Use Bugs (MUS), Memory DeallocationBugs (MDL), and Memory Addressing Bugs (MAD). ThisBF Memory Bugs taxonomy can be viewed as a structuredextension to the memory-related CWEs, allowing bug reporting tools to produce more detailed, precise, and unambiguousdescriptions of identified memory bugs."
"Classifying Memory Bugs Using Bugs Framework Approach- II. BF APPROACH AND METHODOLOGYBF's approach is different from CWE's exhaustive listapproach. BF is a classification. Each BF class is a taxonomiccategory of a weakness type. It relates to a distinct phase ofsoftware execution, the operations specific for that phase andthe operands required as input to those operations"
"Classifying Memory Bugs Using Bugs Framework Approach- II. BF APPROACH AND METHODOLOGYWe define a software bug as a coding error that needsto be fixed. A weakness is caused by a bug or ill-formeddata. A weakness type is also a meaningful notion, asdifferent vulnerabilities may have the same type of underlyingweaknesses. We define a vulnerability as an instance of aweakness type that leads to a security failure. It may havemore than one underlying weaknesses linked by causality."
"Classifying Memory Bugs Using Bugs Framework Approach- II. BF APPROACH AND METHODOLOGYBF describes a bug or a weakness as an improper stateand its transition. The transition is to another weaknessor to a failure. An improper state is defined by the tuple(operation, operand1,.., operandn), where at leastone element is improper. The initial state is always caused bya bug; a coding error within the operation, which if fixed willresolve the vulnerability. An intermediate state is caused byill-formed data; it has at least one improper operand. Rarelyan intermediate state may also have a bug, which if fixedwill also resolve the vulnerability. The final state, the failure,is caused by a final error (undefined or exploitable systembehavior), which usually directly relates to a CWE . Atransition is the result of the operation over the operands."
Classifying Memory Bugs Using Bugs Framework Approach- II. BF APPROACH AND METHODOLOGYBF describes a vulnerability as a chain of improperstates and their transitions. Each improper state is an instanceof a BF class. The transition from the initial state is byimproper operation over proper operands. The transitionsfrom intermediate states are by proper operations with at leastone improper operand.
"Classifying Memory Bugs Using Bugs Framework Approach- II. BF APPROACH AND METHODOLOGYIn some cases, several vulnerabilities have to be presentfor an exploit to be harmful. The final errors resulting fromdifferent chains converge to cause a failure. The bug in atleast one of the chains must be fixed to avoid that failure."
"Classifying Memory Bugs Using Bugs Framework Approach- II. BF APPROACH AND METHODOLOGYWe call a BF class the set of operations, the validcause/consequence relations for these operations, their attributes, and sites. The attributes are qualifiers for the operations and the operands that help understand how severe a bug is. The sites show where in code a bug might occur. The BFclasses are orthogonal by design; their sets of operations donot overlap."
"Classifying Memory Bugs Using Bugs Framework Approach- II. BF APPROACH AND METHODOLOGYThe taxonomy of a particular bug or weakness is basedon one BF class. Its description is an instance of a taxonomicBF class with one cause, one operation, one consequence, andtheir attributes. The operation binds the cause/consequencerelation - e.g., deallocation via a dangling pointer leads to afinal error known as double free."
Classifying Memory Bugs Using Bugs Framework Approach- II. BF APPROACH AND METHODOLOGYThe methodology for developing a BF class is as follows: (1) Identify the phase specific for a kind of bugs. (2)Identify the operations for that phase. (3) Define a BF bugsmodel showing operations flow. (4) Identify all causes. (5)Identify all consequences that propagate as a cause to a nextweakness. (6) Identify all consequences that are final errors.(7) Identify attributes useful to describe such a bug/weakness.(8) Identify possible sites in code.
"Classifying Memory Bugs Using Bugs Framework Approach- III. MEMORY BUGS MODELEach memory related bug or weakness involves onememory operation. Each operation is over a region of memory or over the address needed to reach it. That memory isused for storing data and has an important property: it isfinite. It has boundaries and it has size. We call this pieceof memory, with a well-defined size, an object. It is used tostore a primitive data or a data structure. The memory addressshould be held by at least one pointer or determined as anoffset on the stack, otherwise the object will be unreachable.The object and the pointer are the operands of that memoryoperation."
"Classifying Memory Bugs Using Bugs Framework Approach- III. MEMORY BUGS MODELMemory bugs could be introduced at any of the phasesof an object's lifecycle: address formation, allocation, use,and deallocation. The BF Memory Bugs Model helps identify where in these phases bugs could occur . Thephases correspond to the BF memory bugs classes: MemoryAddressing Bugs (MAD), Memory Allocation Bugs (MAL),Memory Use Bugs (MUS), and Memory Deallocation Bugs(MDL). All possible memory operations are grouped byphase. The presented operations flow helps in identifyingpossible chains of bugs/weaknesses."
"Classifying Memory Bugs Using Bugs Framework Approach- III. MEMORY BUGS MODELThe operations under MAD  are on formingor modifying a pointer: Initialize, Reposition, and Reassign.Bugs in pointer initialization could result in pointers to meaningless objects. Moving a pointer via a bugged Repositioncould get it pointing outside the object bounds. Bugs inReassign could connect a pointer to a wrong object."
"Classifying Memory Bugs Using Bugs Framework Approach- III. MEMORY BUGS MODELThe operations under MUS are on reading or writing thecontent of an object through one of its pointers: Initialize,Read, Write, Clear, and Dereference. Bugs in object initialization could lead to use of random or malicious data. Bugsin write could alter data wrongly. Bugs in Clear could leakconfidential information such as passwords and cryptographicprivate keys. Bugs in Dereference are practically unsuccessfulreading or unsuccessful writing. "
"Classifying Memory Bugs Using Bugs Framework Approach- III. MEMORY BUGS MODELThe operations under MAL are on creating an object orextending it through one of its pointers: Allocate, Extend,and Reallocate-Extend. The operations under MDL are on destroying or reducing anobject through one of its pointer: Deallocate, Reduce, andReallocate-Reduce. Both MAL and MDL operations affect the boundaries and the size of the object. Bugs in Reallocate may concern multiple pointers tothe same object. Allocation in excess or failure to deallocateunused objects could exhaust memory. Excessive reductionof allocated memory could lead to an object that is too littlefor the data it needs to store."
"Classifying Memory Bugs Using Bugs Framework Approach- III. MEMORY BUGS MODELThe very first operation is MAL Allocate an object. Following the green arrows, thefirst operation is MAD Initialize a pointer. Next operation,following the blue arrows, should be MAD Initialize thepointer to the address returned by Allocate. While, followingthe green arrows, next operation should be MAL Allocate anobject at the address the pointer holds."
"Classifying Memory Bugs Using Bugs Framework Approach- III. MEMORY BUGS MODELAfter an object is allocated and its pointer is initialized,it can be used via MUS Read or MUS Write. The boundariesand the size of an object are set at allocation, then they canbe changed by any MAL or MDL operation."
"Classifying Memory Bugs Using Bugs Framework Approach- III. MEMORY BUGS MODELIf an object is owned by more than one pointer, Reallocate (in MAL or MDL) should be followed by Repositionover all these owners. A Deallocate an object operationshould properly be followed by Reassign of all its pointersto either NULL or another object."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESWe define the BF Memory Bugs classes as follows:(a) MAD (Memory Addressing) which has 3 operation values such as Initialize(The first assign of an object address to a pointer,positions the pointer at the start of the object), Reposition (Changes the pointer to another position inside its object) and Reassign( Changes the pointer to a different object).(b) MAL (Memory Allocation) which has 3 operation values that Allocate (Reserves space in memory for an object; defines its initial boundaries and size), Extend(Allocates additional memory for an object in the same space,redefines its boundaries and size) and Reallocate-Extend (Allocates a new larger piece of memory for an object at a new address, copies the object content there, reassigns its,pointer, and deallocates the previous piece of memory)(c) MUS (Memory Use) which has 5 operation values that Initialize(The first write into an object, after it is allocated),Read(Gets content from an object), Write( Puts content into an object),Clear(The very last write into an object, before it is deallocated) and Dereference(e Overreaches Initialize, Read, Write, and Clear, focus is on object access, no matter if it's for reading or for writing)(d) MDL (Memory Deallocation) which has 3 operation values such as Deallocate(Releases the allocated memory of an object),Reduce(Deallocates part of the object memory; redefines its boundaries and size) and Reallocate-Reduce(Allocates a new smaller space in memory for an object at a new address, copies part of the object content there, reassigns the pointer, and deallocates the previous piece of memory)."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESMemory Addressing Bugs (MAD) - The pointer to an object is initialized, repositioned, or reassigned to animproper memory address.Memory Allocation Bugs (MAL) - An object is allocated, extended, or reallocated (while extending) improperly.Memory Use Bugs (MUS) - An object is initialized,read, written, or cleared improperly.Memory Deallocation Bugs (MDL) - An object is deallocated, reduced, or reallocated (while reducing) improperly.Each of these classes represents a phase, aligned with the Memory Bugs Model, and is comprised of sets of operations,cause/consequence relations, and attributes. "
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESA. OperationsAll BF classes are being designed to be orthogonal; theirsets of operations should not overlap. The operations in whichmemory bugs could happen are defined in Table I.The MAD operations are: Initialize (Pointer), Reassign,Reposition. They reflect improper formation of an address.The MAL operations are: Allocate, Extend, and Reallocate-Extend. They reflect improper formation of an object.The MUS operations are: Initialize (Object), Dereference,Read, Write, Clear. They reflect improper use of an object. The MDL operations are: Deallocate, Reduce, Reallocate-Reduce. They reflect improper release of an object.MAD Initialize and MUS Initialize are not overlapping, asthe former is about the address, the latter is about the object."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESB. CausesA cause is either an improper operation or an improperoperand. The values for improper memory operations are:Missing, Mismatched, and Erroneous. See definitions in Table II. The operands of a memory operation are pointer andobject. See definitions in Table III. All values for improperoperands of a memory operation are defined in Table IV.An improper pointer could be a reference. Commentscould be used to provide details, such as the pointer orreference identifier. An improper object could be a primitive data type or a data structure. Comments could be used toprovide details, such as the object data type and identifier.All possible causes for memory bugs are defined inTable II and Table IV. When describing a chain of bugs/weaknesses, the pointerand the object should be analyzed carefully, as they maybe different for each improper state. The description shouldreflect the changes and provide details in the comments."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESTABLE II: Improper OperationsAs being said before,a cause is either an improper operation or an improperoperand.First we should start from improper operartions which are divided by three values.So,memory bugs should be caused from values such asmissing(The operation is absent) and for example <<Missing object initialization>> . Another value of cause is mismatched(The deallocation function does not match the allocation function used for the same object) and for example <<Use of free() onan object allocated with new.>> . The last one value is erroneous(There is a bug is in the implementation of the operation.)  and for example <<Allocation with malloc() returns a non existing address>> ."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESC. ConsequencesA consequence is either an improper operand or afinal error. As a consequence, an improper pointer or animproper object would become a cause for a next weakness.These consequence-cause transitions explain why these twokinds of consequences have the same possible values as thecorresponding kinds of causes .The only kind of MAD consequences is ImproperPointer, which means a MAD bug or weakness is alwaysfollowed by another memory weakness, such as of MAL,MUS, or MDL. The only kind of MUS consequences isMemory Error, which means MUS always ends in a failure."
Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESTABLE III: Operands The operands of a memory operation are pointer(A holder of the memory address of an object) and object(A memory region used to store data).
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESTABLE IV: Improper OperandsThe operands are explained further above separated by pointer and object.(a) Improper PointerThe value NULL Pointer points to the zero address, a specific invalid address.The value Wild Pointer points to an arbitrary address, because it has not been initialized or an erroneous allocation routine is used.The value Dangling Pointer points to the address of its successfully deallocated object.The value Over Bounds points over the bounds of its object.The value Under Bounds points under the bounds of its object.The value Untrusted Pointer is the pointer is modified to an improperly checked address.The value Wrong Position points to a miscalculated position inside object bounds.The value Hardcoded Address points a wrong specific address.The value Casted Pointer is the pointer who does not match the type of the object, due to wrong type casting.The value Forbidden Address points to an OS protected or non-existing address.The value Single Owner of Object is the only pointer of an already allocated object is used to allocate a new object."
Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESTABLE IV: Improper OperandsThe operands are explained above separated by pointer and object b) Improper ObjectThe value Not Enough Allocated is the allocated memory is too little for the data it shouldstore.The Wrong size used is the value used as size does not match the real size ofthe object.
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESTABLE V: Memory ErrorsAll possible memory errors are defined above:The value of memory overflow is the definition for more memory requested than available, which causes a risk for Stack/heap exhaustion.The value of Memory Leak defined by An object has no pointer pointing to it, which causes a risk of Resource exhaustion,Application crash,DoS.The value of Double Free defined by the Attempt to deallocate a deallocated object or via an uninitialized pointer which causes a risk of Arbitrary code execution.The value of Object Corruption defined by Object data is unintentionally altered, which causes a risk of Wrong/unexpected results.The value of Uninitialized Object defined by Object data is not filled in before use,which causes a rick of Controlled or left over data.The value of Not Cleared Object defined by Object data not overwritten before deallocation,which causes a risk of Information exposure(e.g. private keys).The value of NULL Pointer Dereference defined by Attempt to access an object for read or write through a NULL pointer, which causes a risk of Program crash,Arbitrary code execution (in some OSs).The value Untrusted Pointer Dereference defined by Attempt to access an object via an altered pointer, which causes a risk of DoS, Arbitrary code execution.The value of Type Confusion defined by Type Confusion defined by Pointer and object have different types,which causes a risk of Vtable corruption and Hijack.The value of Use After Free defined by the attempt to use a deallocated object,which causes a risk of Arbitrary code execution.The value of Buffer Overflow defined by the Read or write above the object upper bound,which causes a risk of Arbitrary code execution and Information exposure.The value of Buffer Underflow defined by Read or write below the object lower bounds, which causes a risk of Arbitrary code execution and Information exposure.The value of Unitialized Pointer Derefereance defined by the attempt to access an object for read or write via an uninitialized pointer, which control flow hijack."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESD. AttributesAn attribute provides additional useful informationabout the operation or its operands. All Memory Bugs classes have the following attributes:Source Code, Execution Space, and Location.They explain where a bug is in three dimensions: where is the operation in the program, where its code is running, and where the object is stored in memory.All Memory Bugs classes have also the operation attribute Mechanism, but with different possible values."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESD. AttributesFor MAD and MUS Mechanism qualifies an operation as Direct or Sequential, depending on if an object element is accessed directly or after going through previous elements.For MAL and MDL Mechanism qualifies an operation as Implicit or Explicit. For MAL, Implicit means automaticcompile-time allocation. Improper results from implicit allocation are not enough memory allocated or too much memory requested, overflowing the stack (e.g., via a recursion). ForMDL, Implicit means automatic deallocation at the end ofscope. Bugs in automatic memory allocation or deallocationare rare (e.g., the gcc compiler bug [6]). For MAL, Explicitmeans dynamic run time allocation (e.g. using malloc()or new). For MDL, Explicit means dynamic run time deallocation (e.g. using free() or del)."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESD. AttributesMAL and MDL have also the pointer attribute Ownership. It shows how many pointers point to an object: None,Single, and Shared. See definitions of values in Table VIc. ForMAL, it shows how many pointers hold the allocated object.For MDL, if an object has no pointer pointing to it, it willbe unreachable for deallocation in an environment without agarbage collector. Multiple pointers to the same object couldlead to race conditions and dangling pointers.MUS has also the pointer attribute Span. It shows how many bytes are being used: Little, Moderate, Huge, dependingon if those are a few, more than a few and less than one KB or more than one KB."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESD. AttributesTABLE VI: Attributes(a) MAD, MAL, MUS, MDL AttributesAs said before, all Memory Bugs classes have the following attributes:Source Code, Execution Space, and Location.  The source includes the values of codebase(The operation is in programmer's code - in theapplication itself), Third Party(The operation is in a third party library), Standard library(The operation is in the standard library for a particular programming language) and the Language Processor(The operation is in the tool that allows execution or creates executable (compiler, assembler, interpreter). The execution space includes the values of Userland(The bugged code runs in an environment withprivilege levels but in unprivileged mode), Kernel ( The bugged code runs in an environment withprivilege levels with access privileged instructions) and Bare-Metal(The bugged code runs in an environment without privilege control. Usually, the program is the only software running and has total access to the hardware). The location includes the values of stack(The object is a non-static local variable) and heap(The object is a dynamically allocated data structure)."
Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESD. AttributesTABLE VI: Attributes(b) MAD and MUS AttributesFor MAD and MUS Mechanism qualifies an operation as Direct(The operation is performed over a particularobject element) or Sequential(The operation is performed after iterating overthe object elements).
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESD. AttributesTABLE VI: Attributes(c) MAL and MDL AttributesFor MAL and MDL Mechanism qualifies an operationas Implicit(The operation is performed without a functioncall) or Explicit(The operation is performed by a function/method call).The MAL and MDL have also the pointer attribute Ownership. It shows how many pointers point to an object: None(The object has no owner),Single(The object has one owner) and Shared(The object has more than one owner)."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESD. AttributesTABLE VI: Attributes(d) MUS AttributesMUS has also the pointer attribute Span.It shows how many bytes are being used: Little(A few bytes of memory are accessed), Moderate(Several bytes of memory are accessed, but lessthan 1 KB) and Huge( More than 1 KB of memory is accessed)."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESE. SitesMAD sites are any changes to a pointer via assignment(=) or repositioning via an index ([]) or pointer arithmetics(e.g., p++ and p--).MAL sites are any allocation routine (e.g., malloc())or operator (e.g. new), declaration of a variable with implicit allocation, OOP constructor, or extension routine (e.g.,realoc()) or adding elements to a container object.MUS sites are any dereference operators in the sourcecode (*, [], ->, .).MDL sites are any deallocation routine (e.g., free())or operator (e.g. del), end of scope for implicit allocated variables, OOP destructor, or reduction routine (e.g.,realoc()) or removing elements from a container object."
"Classifying Memory Bugs Using Bugs Framework Approach- V. THE BF MEMORY CLASSES AS CWE EXTENSIONBF Memory Bugs taxonomy can be used by bug reporting tools, as it is a structured extension over memoryrelated CWEs. All Memory Error consequences from theBF classes (Table V) relate to one or more CWEs."
"Classifying Memory Bugs Using Bugs Framework Approach- V. THE BF MEMORY CLASSES AS CWE EXTENSIONWe have generated a digraph (Fig. 6) of all memoryrelated CWEs to show how they correspond to the possibleBF Memory Error consequences (Table V). An edge starts ata parent CWE and ends at a child CWE. The outline style ofa CWE node indicates the CWE level of abstraction: pillar,class, base, or variant. Bug reporting tools would use base orvariant CWEs, but they may also use higher abstraction levelCWEs if there is not enough specific information about thebug or if there is no related base CWE."
"Classifying Memory Bugs Using Bugs Framework Approach- V. THE BF MEMORY CLASSES AS CWE EXTENSIONThe digraph helped us identify clusters of memoryrelated CWEs. All these CWEs can be tracked as childrenof the pillar CWE-664, with the only exception of CWE-476(NULL Pointer Dereference). The largest cluster comprisesCWE-118 and the children of CWE-119, which are weaknesses associated with reading and writing outside the boundaries of an object. The second cluster comprises the childrenof CWE-400 and CWE-665, which are mainly weaknessesrelated to memory allocation and object initialization. Thechildren of CWE-404, which are weaknesses associated withimproper memory cleanup and release, form the third cluster.The smallest cluster comprises CWE-704, CWE-588 andCWE-843, which are memory use or deallocation weaknessesdue to the mismatch between pointer and object types."
"Classifying Memory Bugs Using Bugs Framework Approach- V. THE BF MEMORY CLASSES AS CWE EXTENSIONThe color of a CWE node indicates the BFmemory class associated with that CWE. A BF class isassociated with a CWE if the BF class has a Memory Errorconsequence covered by the CWE description. CWEs relatedto the BF MUS memory errors are presented in blue, CWEsrelated only to MAL are presented in pink, and CWEs relatedto both MAL and MDL are presented in green."
"Classifying Memory Bugs Using Bugs Framework Approach- V. THE BF MEMORY CLASSES AS CWE EXTENSIONMost of the BF MUS Memory Error consequences relate to CWEs from the CWE-118 cluster. TheMemory Error consequences from BF MAL and BF MDL relate to CWEs across clusters. Notethat the BF MAD class has no Memory Errorconsequences, so it does not directly relate to any CWE."
"Classifying Memory Bugs Using Bugs Framework Approach- V. THE BF MEMORY CLASSES AS CWE EXTENSIONThe BF Memory Bugs model reflects the lifecycle of an object. While the pillar CWE-664 reflects the""lifetime of creation, use, and release"" of a resource, it isquite broad. It is the parent of many CWEs that are not strictlymemory-related. We use asterisks (*) to denote CWEs that areabout any resource. CWE-704 is not a memory-related CWE,but is visualized on the digraph to show all the parent-childrelationships."
"Classifying Memory Bugs Using Bugs Framework Approach- V. THE BF MEMORY CLASSES AS CWE EXTENSIONThe identified clusters of memory CWEs do not strictlycorrespond to the phases of address formation, allocation,use, and deallocation. CWEs related to a phase appear inmore than one cluster. In addition, CWE-118 and CWE-119are strictly about memory but cover more than one phase.Viewed as a structured extension, the BF Memory Bugsclasses relate to CWEs through particular Memory Errorconsequences. For BF MAL: Memory Overflow - relates toCWEs: 400*, 770*, and 789; Memory Leak - to CWEs: 401,404*, 771*, and 772*; Double Free - to CWE-415;  ObjectCorruption - to CWEs: 404*, 590, 761, 762, and 763."
"Classifying Memory Bugs Using Bugs Framework Approach- V. THE BF MEMORY CLASSES AS CWE EXTENSIONFor BF MUS: Uninitialized Object - relates to CWEs:456, 457, 665*, 908*, and 909*; Not Cleared Object - toCWEs: 226*, 244, and 459*; NULL Pointer Dereference -to CWE-476; Untrusted Pointer Dereference - to CWEs: 119and 822; Type Confusion - to CWEs: 588 and 843*; UseAfter Free - to CWEs: 119, 416, and 825; Buffer Overflow- to CWEs: 118, 119, 120, 121, 122, 123, 125, 126, 466,805, 806, 787, and 788; Buffer Underflow - to CWEs: 118,119, 122, 123, 124, 125, 127, 466, 786, 787, 805, and 806;Unitialized Pointer Dereference - to CWEs: 119 and 824.There are no related CWEs to BF MUS Object Corruption."
"Classifying Memory Bugs Using Bugs Framework Approach- V. THE BF MEMORY CLASSES AS CWE EXTENSIONFor BF MDL: Memory Leak - relates to CWEs: 401,404*, and 771*; Double free - to CWE-415; Object Corruption - to CWEs: 404*, 761, 762, and 763."
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONIn this section, we use the new BF Memory Bugs classesfor precise descriptions of real world software vulnerabilities.We also provide the real world fixes of each bug."
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONA. CVE-2018-20991 - Rust SmallVec Iterator PanicThis vulnerability is listed in CVE-2018-20991. The source code could be found at. InRust, a panic is an unrecoverable error that terminates thethread, possibly unwinding its stack (calling destructors as ifevery function instantly returned)."
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONA. CVE-2018-20991 - Rust SmallVec Iterator Panica) Brief Description: Rust is a multi-paradigmprogramming language focused on safe concurrency. It hasa similar syntax to C++ and offers features to deal withdynamic memory allocation, such as smart pointers [11]. Ingeneral, a Rust programmer does not need to keep trackof memory allocation and deallocation, as the language isdesigned to be memory safe this way"
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONA. CVE-2018-20991 - Rust SmallVec Iterator Panicb) Analysis: The versions before Rust 0.6.3 havea bug in the lib.rs file. The insert_many() methodin the SmallVec class has two parameters: an iterableI and an index. The method inserts all elements in theiterable I at position index, shifting all the followingelements backwards. In the SmallVec class, if an iterator passed to SmallVec::insert_many() panics inIterator::next, the destructor is called while the vectoris in an inconsistent state, possibly causing double free(deallocation via references to same object). "
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONA. CVE-2018-20991 - Rust SmallVec Iterator Panicc) The Fix: To fix the bug, the Rust community opted to set the SmallVec length to index, callinsert_many(), and then update the length. With thisfix, if an iterator panics, a memory leak occurs [12]. Thedevelopers downgraded the bug to avoid double free as aconsequence, which could lead to arbitrary code execution.Now they have a memory leak."
Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONB. CVE-2014-0160 - Heartbleed Buffer OverflowThis vulnerability is listed in CVE-2014-0160 and discussed in [13]. The source code could be found at [14].
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONB. CVE-2014-0160 - Heartbleed Buffer Overflowa) Brief Description: Heartbleed is a vulnerabilitydue to a bug in the OpenSSL - a crypto library for theTransport Layer Security (TLS) and Secure Sockets Layer(SSL) protocols. Using the heartbeat extension tests in TLSand Datagram Transport Layer Security (DTLS) protocols,a user can send a heartbeat request to a server. The requestcontains a string and a payload unsigned integer, whichvalue is expected to be the string size. The server respondswith the same string. However, due to the bug, a malicioususer could set the payload as big as 65535 and the serverwould read out of bounds. This could expose confidentialinformation that was not cleared before release"
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONB. CVE-2014-0160 - Heartbleed Buffer Overflowb) Analysis: The TLS and DTLS implementations in OpenSSL 1.0.1 before 1.0.1g have a bug inthe d1_both.c and t1_lib.c files. In the Heartbleedattack, the software stores the user data in an arrays?>s3?>rrec.data[0]. The size of that array is muchless than the huge 65535 bytes payload. The software doesnot check the size of the data (s?>s3?>rrec.length)towards the value of the payload. It assumes these numbersare equal and using memcpy() reads payload consecutivebytes from the array, beginning at its first byte, then sendsthem to the malicious user."
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONB. CVE-2014-0160 - Heartbleed Buffer Overflowc) The Fix: To fix the bug the openSSL team addeda bound check for the array size [15]. We should note thatin Fig. 9 the Wrong Size Used cause is a consequence froma missing Verify operation of a preceding Data VerificationBug (DVR) [1], which is beyond the scope of this paper."
Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONC. DiscussionThe BF taxonomy of a vulnerability can help identifyexploit mitigation techniques for a particular weakness types.For that we should connect the BF taxonomy to an appropriate attack model.
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONC. DiscussionFor memory bugs, we can use the classic memorycorruption attack model of Szekeres et al. [16] that systematizes the memory protection techniques. The model has sixsteps towards the ultimate goal of an attacker. Its very firstlevel is on memory safety, where an attacker can start anexploitation with an invalid pointer dereference. This kind ofinvalid pointer corresponds to the improper pointer states thatdefine some of the causes for the BF Memory Bugs classes."
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONC. DiscussionUsing the BF description of a vulnerability and following the attack model we can identify effective mitigationsagainst possible attacks. Let's take, for example, a BufferOverflow that is caused by Read Over Bounds. Following theSzekeres et al. model, such a bug would allow an attacker toaccess program data, leading to information leakage."
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONC. DiscussionTo make use of the collected data, the attacker shouldbe able to interpret it. Probabilistic methods such as dataspace randomization (DSR) could mitigate the attack, whilean address space location randomization (ASLR) will notdo it [17]. The values of the Location and Execution Spaceattributes of the object help identify where in the memorylayout the mitigation technique should be put in place."
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONC. DiscussionThe Szekeres et al. model, however does not cover bugsrelated to some BF memory operations, such as allocation,reallocation, and initialization. It does not cover any memoryaddressing bugs (MAD) and it is not concerned describinghow a pointer becomes invalid. A key point here is thatSzekeres et al. look at memory corruption bugs from attacksperspective, while we focus on systematizing information thatis sufficient to fix a bug."
"Classifying Memory Bugs Using Bugs Framework Approach- VII. CONCLUSIONIn this paper, we introduce four new BF classes: MemoryAddressing Bugs (MAD), Memory Allocation Bugs (MAL),Memory Use Bugs (MUS), and Memory Deallocation Bugs(MDL). We present their operations, along with the possiblecauses, consequences, attributes, and sites."
"Classifying Memory Bugs Using Bugs Framework Approach- VII. CONCLUSIONWe analyze particular vulnerabilities related to theseclasses and provide precise BF descriptions. The BF structured taxonomies of memory corruption vulnerabilities showthe initial error (the bug) providing a quite concise and stillfar more clear description than the unstructured explanationsin current repositories, advisories, and publications."
"Classifying Memory Bugs Using Bugs Framework Approach- VII. CONCLUSIONLinking the BF Memory Bugs model and taxonomy toan attack model (e.g. Szekeres et al. model) would providethe means of covering the memory corruption vulnerabilitieslandscape. For example, the first layer of the Szekeres modelcould connect with the BF causes defined in Section IV-B.As part of that, the notion of invalid pointer should not berestricted to dangling pointers and out of bounds pointers;refinement to the causes in Table IVa should be considered.The BF Memory Bugs taxonomy can be used by bugreporting tools, as it can be viewed as a structured extensionover the memory related CWEs. Furthermore, the BF descriptions of particular vulnerabilities can be used to identify exploit mitigation techniques."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- AbstractIn this work, we present an orthogonal classification of input/output check bugs, allowing precise structured descriptions of related software vulnerabilities. We utilizethe Bugs Framework (BF) approach to define two languageindependent classes that cover all possible kinds of data check bugs. We also identify all types of injection errors, as they arealways directly caused by input/output data validation bugs.In BF each class is a taxonomic category of a weakness typedefined by sets of operations, cause/consequence relations,and attributes. A BF description of a bug or a weakness isan instance of a taxonomic BF class with one operation, onecause, one consequence, and their attributes. Any vulnerabilitythen can be described as a chain of such instances and theirconsequence-cause transitions. With our newly developed DataValidation Bugs and Data Verification Bugs classes, we confirmthat BF is a classification system that extends the CommonWeakness Enumeration (CWE). It allows clear communicationabout software bugs and weaknesses, providing a structuredway to precisely describe real-world vulnerabilities.Keywords-Bug classification, bug taxonomy, software vulnerability, software weakness, input validation, input sanitization, input verification, injection."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- I. INTRODUCTIONThe most dangerous software errors that open the doorsfor cyberattacks are injection and buffer overflow. Injection is directlycaused by improper input/output data validation. Bufferoverflow may be a consequence of improper input/output dataverification. Classifying all input/output data check bugsand defining the types of injection errors would allow precisecommunication and help us teach about them, understand andidentify them, and avoid related security failures."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- I. INTRODUCTIONThe Common Weakness Enumeration (CWE) and theCommon Vulnerabilities and Exposures (CVE) are wellknown and used lists of software security weaknesses and vulnerabilities. However, they have problems. CWE's exhaustive list approach leads to gaps and overlaps in coverage, as demonstrated by the National Vulnerability Database (NVD)effort to link CVEs to appropriate CWEs . Many CWEsand CVEs have imprecise and unstructured descriptions. Forexample, CWE-502 is imprecise as it is not clear what""sufficiently"" and ""verifying that data is valid"" mean. Dueto the unstructured description of CVE-2018-5907, NVD has changed the assigned CWEs over time, and currently maps CWE-190, while the cause is CWE-20 and the full chainis CWE-20-CWE-190-CWE-119 - lack of input verificationleads to integer overflow and then to buffer overflow."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- I. INTRODUCTIONThe Bugs Framework (BF) builds on these commonly used lists of software weaknesses and vulnerabilities,while addressing the problems that they have. It is being developed as a structured, complete, orthogonal, and languageindependent classification of software bugs and weaknesses.Structured means a weakness is described via one cause,one operation, one consequence, and one value per attributefrom the lists defining a BF class. This ensures precisecausal descriptions. Complete means BF has the expressiveness power to describe any software bug or weakness. This ensures there are no gaps in coverage. Orthogonal means thesets of operations of any two BF classes do not overlap.This ensures there are no overlaps in coverage. BF is alsoapplicable for source code in any programming language.The cause/consequence relation is a key aspect of BF'smethodology that sets it apart from any other efforts. Itallows describing and chaining the bug and the weaknessesunderlining a vulnerability, as well as identifying a bug froma final error and what is required to fix the bug."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- I. INTRODUCTIONWe utilize the BF approach to define two languageindependent, orthogonal classes that cover all possible kindsof data check bugs and weaknesses: Data Validation Bugs(DVL) and Data Verification Bugs (DVR). The BF DataCheck Bugs taxonomy can be viewed as a structured extension to the input, output, and injection-related CWEs, allowing bug reporting tools to produce more detailed, precise,and unambiguous descriptions of identified data validationand data verification bugs."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- I. INTRODUCTIONThe main contributions of this work are: i) we create amodel of data check bugs; ii) we create a taxonomy that hasthe expressiveness power to clearly describe any data checkbugs or weaknesses; iii) we confirm our taxonomy covers thecorresponding input/output CWEs; iv) we showcase the useof our input/output check bugs taxonomy.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- I. INTRODUCTIONWe achieve these contributions respectfully via: i) identifying the operations, where data validation and data verification bugs could happen; ii) developing two new structured,orthogonal BF classes: DVL and DVR, while also definingfive types of injection errors; iii) generating digraphs ofCWEs related to input/output validation weaknesses, as wellas to injection errors, and mapping these CWEs to BF DVLand BF DRV by operation and by consequence; iv) describingreal-world vulnerabilities using BF DVL and BF DVR: CVE2020-5902 BIG-IP F5, CVE-2019-10748 Sequelize SQL Injection, and the DVR bug in CVE-2014-0160 Heartbleed."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- I. INTRODUCTIONThe rest of the paper is organized as follows: InSection II, we recall BF's approach and methodology. InSection III, we analyze the types of data check bugs anddefine the BF Data Check Bugs model. In Section IV, wepresent our new BF DVL and BF DVR classes. In Section V,we analyze the correspondence of the input, output, andinjection-related CWEs to the new BF classes. In Section VI,we use the BF Data Check Bugs taxonomy to provide better,structured descriptions of real-world vulnerabilities. Finally, in Section VII we discuss related worksand in Section VIII we summarize the paper contributionsand we propose future works."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- II. BF APPROACH AND METHODOLOGY BF describes a bug or a weakness as an improper stateand its transition. The transition is to another weaknessor to a failure. An improper state is defined by the tuple(operation, operand1,..., operandn) where at leastone element is improper. The initial state is always caused bya bug - a coding error within the operation, which, if fixed,will resolve the vulnerability. An intermediate state is causedby ill-formed data; it has at least one improper operand. Thefinal state, the failure, is caused by a final error (undefinedor exploitable system behavior) that usually directly relatesto a CWE. A transition is the result of the operation over theoperands."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- II. BF APPROACH AND METHODOLOGY BF describes a vulnerability as a chain of improperstates and their transitions. Each improper state is an instanceof a BF class. The transition from the initial state is byimproper operation over proper operands. The transitionsfrom intermediate states are by proper operations with at leastone improper operand.
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- II. BF APPROACH AND METHODOLOGY Operations or operands improperness defines the causes.A consequence is the result of an operation over its operands.It becomes a final error or the cause for a next weakness.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- II. BF APPROACH AND METHODOLOGY A BF class is a taxonomic category of a weakness type,defined by a set of operations, all valid cause?consequencerelations, and a set of attributes. The taxonomy of a particularbug or weakness is based on one BF class. Its description isan instance of a taxonomic BF class with one cause, oneoperation, one consequence, and their attributes. The operation binds the cause/consequence relation - e.g., underrestrictive sanitization policy leads to a final error known asSQL (Structured Query Language) injection."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- II. BF APPROACH AND METHODOLOGY CWEs coverage by any newly developed BF classescan be visualized via digraphs, based on CWEs parentchild relationships. Once analyzed, these digraphs can help understand CWEs structure and how they translate to BF."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- II. BF APPROACH AND METHODOLOGY The taxonomies of newly developed BF classes canbe demonstrated by providing structured BF descriptions ofappropriate CVEs.
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- II. BF APPROACH AND METHODOLOGY The methodology for developing a BF class comprisesidentifying/defining: (1) the phase specific for a kind of bugs;(2) the operations for that phase; (3) the BF Bugs modelwith operations flow; (4) all causes; (5) all consequences thatpropagate as a cause to a next weakness; (6) all consequences that are final errors; (7) attributes useful to describe such a bug/weakness; (8) the possible sites in code; (9) CWEdigraphs by class and consequence; (10) CVE test cases.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- II. BF APPROACH AND METHODOLOGY Data should be checked to ensure proper results from itsprocessing. It should adhere to object data types acceptable bythe software. In a paper with title ""Classifying Memory Bugs UsingBugs Framework Approach written by Bojanova and Galhardo, define an objectas a piece of memory with well-defined size that is used tostore primitive data or a data structure. As input, primitivedata are checked and sanitized on string-of-characters level.A character - e.g., an ASCII (American Standard Code forInformation Interchange) character - is a single symbol, suchas an alphabet letter, a numeric digit, or a punctuation mark.Data structures in turn are built on primitive data but can alsohave a higher level of syntax and semantics rules."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- III. DATA CHECK BUGS MODELData check comprises data validation, where data syntaxgets checked for being well-formed, and data verification,where data semantics gets verified for being accurate. TheBF model separates data semantics check as data verification,although OWASP (Open Web Application Security Project)puts it under input validation."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- III. DATA CHECK BUGS MODELValidation is about accepting or rejecting data basedon its syntax: it checks if data are in proper format (grammar). For example, checking if data consist of digits only or checking the syntax of an XML (Extensible MarkupLanguage) document against a DTD (XML Document TypeDefinition) is data validation. Once data syntax is checked itmay be sanitized. Sanitization is about neutralizing, filtering,or repairing data via escaping, removing, or adding symbolsin data, correspondingly. An example of data sanitizationwould be removing a special character such as '/' or addinga closing parenthesis ')'. The validate and sanitize operations use specific policies, such as to check against safelist,denylist, format (e.g., defined via regular expressions), orlength. A safelist defines a set of known good content. Adenylist defines a set of known bad content; it helps rejectoutright maliciously malformed data. Regular expressionsdefine format patterns that data (viewed as strings) shouldmatch. They could be used for safelists and denylists."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- III. DATA CHECK BUGS MODELVerification is about accepting or rejecting data based onits semantics: it checks if data have proper value (meaning).For example, checking if a start date is before an end date, orchecking the type of an XML document against a PowerPointXSD (XML Schema Definition) is data verification. Oncedata semantics is checked, it may be corrected via assigninga new value or via removing data. An example of datacorrection would be setting the size to the buffer's upperbound when the size that is supplied is larger than that upperbound. The verify and correct operations use specific policiesto, for example, check data against a value (incl. NULL orlist of values), quantity, range, type, or other business rules."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- III. DATA CHECK BUGS MODELData check bugs could be introduced at any of the datavalidation and data verification phases. Each bug or weaknessinvolves one data check operation: validate, sanitize, verify,or correct. Each operation is over already-canonicalized1 dataand the policy (the rules) against which it gets checked."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- III. DATA CHECK BUGS MODELThe BF Data Check Bugs model helped usidentify the phases and the operations where such bugs couldoccur. The phases correspond to the BF Data Check Bugsclasses: Data Validation Bugs (DVL) and Data VerificationBugs (DVR). All data check operations are grouped by phase.The operations under DVL are on checking data syntax: Validate and Sanitize. The operations under DVRare on checking data semantics: Verify and Correct. Data could bevalidated and verified or only directly verified. The presented operations flow helps in identifying possible chains of bugs/weaknesses.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESWe define the BF Data Check Bugs classes as follows:-Data Validation Bugs (DVL):Data are validated (syntaxcheck) or sanitized (escape, filter, repair) improperly.-Data Verification Bugs (DVR): Data are verified (semantics check) or corrected (assign value, remove) improperly."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESA. OperationsAll BF classes are being designed to be orthogonal;their sets of operations should not overlap. The operationsin which data check bugs could happen correspond to theoperations in the BF Data Check Bugs model. The DVL operationsare Validate and Sanitize. They reflect the improper check andmodification of data syntax. The DVR operations are Verifyand Correct. They reflect the improper check and modificationof data semantics.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESB. CausesA cause is either an improper operation or an improperoperand. If a BF class instance is the first in a chaindescribing a vulnerability, it is always caused by an improperoperation. The values for improper data check operationsare Missing, Erroneous, Under-Restrictive Policy, and OverRestrictive Policy. "
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESB. CausesThe operands of a data check operation are data andpolicy. An improper operand isdata or policy that has been modified by an operation of aprevious weakness, such as decode, decrypt, and convert."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESB. CausesAll values for an improper operand of a data checkoperation are defined in Table IV. Improper Policy as datafrom a previous weakness is a possible cause only for DVL.Improper Data could be of a primitive data type (e.g., a string,a number) or a data structure. Comments could be used toprovide more details such as data type and variable name."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE I: Operations(a) DVL (Data Validation) has two operations.The first one is Validate defined by Checking data syntax (proper form/grammar) in order to accept (and possibly sanitize) or reject it. Includes checking for missing symbols/elements.The second one is sanitize defined by Modifying data (neutralize/escape, filter/remove, repair/add symbols) in order to make it valid (well-formed).(b) DVR (Data Verification) has two operations. The first one is Verify which can be defined by checking data semantics (proper value/meaning) in order to accept (and possibly correct) or reject it.The second one is Correct which can be defined by modifying data (assign new value, remove), in order to make it accurate."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE II: Improper OperationsThe values for improper data check operations are four.The first value is Missing which means that the operation is absent(for example Missing data sanitization). The second value is Erroneous which means that there's a bug in the operation implementation (incl. how it checksagainst a policy) for instance Using greater than (>) when checking for upper range or Using not equal to (!=) when comparing to safelist values. The third value is Under-Restrictive Policy which means that accepts bad data for instance Permissive safelist or regular expression or Incomplete denylist. The fourth value Over-Restrictive Policy which means that rejects good idea for instance Over-restrictive denylist or regular expression.
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESC. ConsequencesA consequence is either a final error or a wrong resultfrom the operation that propagates as an improper operandfor a next weakness.
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESC. ConsequencesImproper validation or sanitization may directly lead tofinal injection errors. Any other improper data check in anyof the phases would lead to improper data for anoperation in a next weakness.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESC. ConsequencesImproper Data is the only possible improper operand asa consequence from DVL or DVR. All its possible valuesare defined in Table V. As a consequence, improper datawould become a cause for an operation of a next weakness.These consequence-cause transitions explain why InvalidData appears in both Table IV and Table V."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESC. ConsequencesThe only kind of DVR consequences (Table Vb) isimproper operand for next weakness. This means a DVR bugor weakness is always followed by another weakness or achain of weaknesses leading to a final error such as bufferoverflow or memory overflow.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESC. ConsequencesAll DVL final errors are injection errors. We also identifyand define in Table VI five types of injection errors: query injection, command injection, source code injection, parameterinjection, and file injection. All of them, except some source code injections, are due to data with missing, additional, or inconsistent special elements (symbols that can be interpretedas control elements or syntactic markers). The BF modelseparates query injection and command injection from sourcecode injection, although they are commonly discussed underthe umbrella term ""code injection"" . All the possible types of data check errors that end in failureright after the current bug/weakness (as an instance of a BFclass) are DVL final errors, representing the types of injectionerrors."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE III: OperandsThe operands of a data check operation are data and policy. The data can by defined by a string of characters (symbols like letter, digit, punctuation) with clearly defined syntax and semantics. The policy can be defined by Lists or rules for checking data syntax and semantics. For example, safelist, denylist, format (e.g., DTD-XML Document Type Definition), and length; or value (incl. NULL or list ofvalues), quantity, range, and type (e.g., a PowerPoint XSD)."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE IV: Improper Operands - as DVL/DVR Causes(a) Improper Data (from previous operation) - as DVL Cause have two values which are Corrupted Data and Tampered Data. The Corrupted Data can be defined by Unintentionally modified data due to a previous weakness(e.g., with a decompress or a decrypt operation) that if notsanitized would end-up as invalid data for next weakness. The Tampered Data can be defined by Maliciously modified data due to a previous weakness (e.g., with a deserialize, authorize, or crypto verify operation) thatwould lead to injection error."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE IV: Improper Operands - as DVL/DVR Causes(b) Improper Data (from previous operation) - as DVR Cause have one value which is Invalid Data. The Invalid Data are Data with harmed syntax due to sanitization errors.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE IV: Improper Operands - as DVL/DVR Causes(c) Improper Policy (from previous operation) - as DVL Cause have two values.The first value is CorruptedPolicy which means Unintentionally modified policy due to a previous weakness (e.g., with a decompress operation).The second value is Tampered Policy which means Maliciously modified policy due to a previous weakness (e.g., with an authorize operation)."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE V: Improper Operands - as DVL/DVR Consequences(a) Improper Data for Next Operation - as DVL/DVR Consequence have one value which is Invalid Data.The Invalid Data are Data with harmed syntax due to sanitization errors.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE V: Improper Operands - as DVL/DVR Consequences(b) Improper Data for Next Operation - as DVR Consequence have three values. The first value is Wrong value which means that there are Data with harmed semantics; not accurate value (e.g. outside of a range). The second value is Inconsistent Value which means that Data value is inconsistent with the value of a related data (e.g., inconstancy between the value of a size variable and the actual buffer size). The third value is Wrong Type which means that there is Data with wrong data type."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESD. AttributesAn attribute provides additional useful information aboutthe operation or its operands. All possible attributes for datacheck bugs are defined in Table VII. The operation attributesSource Code and Execution Space explain where a bug isor where the operation is in the program and where its coderuns. The data attribute State explains where the data comefrom. See definitions of these attributes' values in Table VIIa.
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESD. AttributesBoth DVL and DVR also have the operation attributeMechanism but with different possible values that are specific to the policies the operations could use to check data. See definitions of this attribute values in Table VIIb and Table VIIc.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VI: Injection Errors - as DVL ConsequencesAll DVL final errors are injection errors. We also identify and define in this Table the five types of injection errors: query injection, command injection, source code injection, parameterinjection, and file injection."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VI: Injection Errors - as DVL ConsequencesThe value Query Injection is defined by Malicious insertion ofcondition parts (e.g. or 1==1) or entire commands (e.g., drop table) into an input used to construct a database query. Some  query injections for example are SQL Injection, No SQL Injection, XPath Injection, XQuery Injection,LDAP Injection."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VI: Injection Errors - as DVL ConsequencesThe value Command Injection is defined by Malicious insertion of new commands into the input to a command that is sent to an operating system (OS) or to a server. Some Command Injections for example are OS Command Injection, Regular Expression Injection,IMAP/SMTP CommandInjection,Object Injection (JSON server side)."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VI: Injection Errors - as DVL ConsequencesThe value Source Code Injection is defined by Malicious insertion of new code (incl. with <> elements) into input used as part of an executing application code. Some Source Code Injection examples are Cross Site Scripting (XSS), CSS Injection, Eval Injection, EL Injection,JSON Injection (Client or Server Side)."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VI: Injection Errors - as DVL ConsequencesThe value Parameter Injection is defined by Malicious insertion of data (e.g., with & parameter separator) into input used as parameter/argument in other parts of code. Some Parameter Injection examples are Argument Injection, Format String Injection, Email Injection, HTTP Header Injection (including Server Header Injection),  Reflection Injection, Flash Injection, CRLF Injection (incl. HTTPHeader Splitting)."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VI: Injection Errors - as DVL ConsequencesThe value File Injection is defined by Malicious insertion of data (e.g. with .. and / or with file entries) into input used to access/modify files or as file content. Some File Injection examples are CSV, Temp, Log Entry Injection, XML Injection, CRLF Injection (incl. in as inlog entry files), Relative Path Traversal, Absolute Path Traversal."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESE. SitesA site for input/output check bugs is any part of the code that should check and sanitize data syntax or check and correct data semantics.
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VII: Attributes(a) DVL and DVR AttributesThe operation attributes Source Code and Execution Space explain where a bug is and where the operation is in the program and where its code runs.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VII: Attributes(a) DVL and DVR AttributesThe operation attribute called Source Code have four values. The first value is Codebase which is defined by the operation is in the programmer's code - in the application itself.The second value is Third Party which is defined by the operation is in a third-party library. The third is Standard Library which is defined by The operation is in the standard library for a particular programming language. The fourth value is Language Processor which is defined by the operation is in the tool that allows execution or creates executables (compiler, assembler, interpreter)."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VII: Attributes(a) DVL and DVR AttributesThe operation attribute called Execution Space have three values. The first value called Local is defined by the bugged code runs in an environment with access control policy with limited (local user)permission. The second value called Admin is the bugged code runs in an environment withaccess control policy with unlimited (admin user) permission. The third value called Bare-Metal is the bugged code runs in an environment without privilege control. Usually, the program is theonly software running and has total access to the hardware."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VII: Attributes(a) DVL and DVR AttributesThe data attribute called State explains where the data come from. The state has four values.The first value called Entered is Data when comes from user interface (e.g. text field). The second value called Stored is Data when comes from permanent storage (e.g. file, database on a storage device). The third value called In Use is Data when comes from volatile storage (e.g., RAM, cache memory). The fourth value called Transferred is Data when comes via network (e.g., connecting analog device or another computer)."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VII: Attributes(b) DVL AttributeBoth DVL and DVR also have the operation attribute Mechanism but with different possible values that are specific to the policies the operations could use to check data.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VII: Attributes(b) DVL AttributeDVL have the operation attribute Mechanism with four values. The first value is Safelist which is the Policy based on a set of known good content. The second value is Denylist which is the Policy based on a set of known bad content; helps reject outright maliciously malformed data. The third value is Format which is the Policy based on syntax format (e.g., defined via regular expression). The fourth value is Length which is the Policy based on allowed number of characters in data. Note that this is not about the data value as size of an object."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VII: Attributes(b) DVR AttributeDVR have the operation attribute Mechanism with five values. The first value called Value is defined by Checking data for a specific value (incl. NULL or list of values). The second value called Quantity is defined by Checking data for a specific measurable value (e.g., size, time, rate, frequency). The third value called Range is defined by Checking data are within a (min, max) interval. The fourth value called Type is defined by Checking data type (e.g., int, float, XSD-XML Schema Definition, or specific structure/object). The fifth value called Other rules is defined by Checking data against other business logic."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONIn this section, we analyze the correspondence of theinput, output, and injection-related CWEs  to the two newBF DVL and DVR classes. We show that the BF classescover all related CWEs, and potentially beyond, while (asdemonstrated later in Section VI) providing a better structuredway for describing these kinds of bugs/weaknesses"
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONThe BF classes ensure precise causal descriptions, as aweakness is described via one cause, one operation, and oneconsequence, while the CWEs only enumerate weaknesses.The CWEs exhaustive list approach is prone to gaps incoverage: some weakness types may be missing. The CWEsalso have overlaps in coverage, including via over detailing(e.g., CWE-23 children's path traversal variations). While bytheir nature, the BF classes are complete and orthogonal,assuring no gaps and no overlaps in coverage. We map a CWE to a BF class by an operation and/or a consequence from the lists defining the BF class. Through these relationships,the BF classes can be viewed as structured extensions to theinput, output, and injection-related CWEs."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONThe BF Data Check Bugs classes relate to particularCWEs by BF DVL and DVR operations and/or consequences.We generated a digraph of all input- and output-check-relatedCWEs, including the injection-related CWEs, to show thiscorrespondence both by operation and by consequence. In the digraph, an edge starts at a parent CWE and ends at a child CWE. The outline style of a CWE node indicates the CWE level of abstraction: pillar, class,base, or variant."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONAlmost all of the 162 CWEs, visualized on the digraph, can be tracked as descendants of the pillar CWE-707; exceptions are CWEs 15, 73 (its child 114), 98, 134, 183, 184, 185 (and its children 186 and 625), 428, 472, 565, and 913."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONAnalyzing the digraph, we see that the pillar CWE707 reflects neutralization of malformed messages; it is quite broad. It is the parent of several CWEs that are not strictlyinput/output check related."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONThe digraph helped us identify seven distinct clusters ofCWEs with parent CWEs 20, 22, 41, 74, 116, 138, and 228."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONThe outline color of a CWE node indicates theBF class(es) and operation(s) associated with that CWE: DVLValidate, DVL Sanitize, DVR Verify, and DVL Validate andDVR Verify. There are no CWEs that relate to DVR Correct.The CWE-20 cluster is the only one that corresponds to DVRVerify. However, some of its descendants correspond also toDVL Validate. The CWE-41 and CWE-228 (except 3 nodes)clusters correspond to DVL Validate. The rest of the clusters,CWE-22, CWE-74, CWE-116, and CWE-138, correspond toDVL Sanitize."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONThe outline color of a CWE node indicatesthe BF class consequence associated with that CWE: QueryInjection, Command Injection, Source Code Injection, Parameter Injection, File Injection, Invalid Data, Wrong Value, Inconsistent Value, or Wrong Type."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONThe CWE-74 cluster is all about injection; the largestgroup there is Source Code Injection, then are Query Injectionand Command Injection, and a few nodes of File Injectionand Parameter Injection. CWEs 74, 75, 76, 913, 914 arenot colored, as they are about general injection errors. TheCWE-22 and CWE-41 clusters are all about File Injection.The CWE-138 cluster is mostly about Parameter Injectionand some Source Code Injection. Some of the CWE-138nodes correspond to the DVL Invalid Data for Next Operationconsequence. The CWE-20 cluster (which is DVR related)has nodes corresponding to the DVR Wrong Data for NextOperation consequences; however, some of these CWEsdescribe only causes and do not list consequences."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONAll relationships to input, output, and injection CWEs by BF DVL and BF DVR consequences are asfollows:1) The DVL class relates to CWEs through its Wrong Datafor Next Operation consequence as follows:  Invalid Data - CWEs: 138, 153, 155, 158, 159, 160,162, and 164."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONAll relationships to input, output, and injection CWEs by BF DVL and BF DVR consequences are asfollows:2) The DVL class relates to CWEs also through its Injection Error consequences as follows:Query Injection - CWEs: 89, 90, 91, 564, 643, 652,and 943; Command Injection - CWEs: 77, 78, and 624;Source Code Injection - CWEs: 79, 80, 81, 83, 82,85, 86, 87, 94, 95, 96, 97, 98, 149, 692, 917, and1336; Parameter Injection - CWEs: 88, 93, 113, 134, 140,141, 142, 143, 144, 145, 146, 147, 148, 150, 151, 152,154, and 157; File Injection - CWEs: 22, 23, 24, 25, 26, 27, 28, 29,30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,58, 73, 99, 117, 641, and 1236."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONAll relationships to input, output, and injection CWEs by BF DVL and BF DVR consequences are asfollows:3) The DVR class relates to CWEs through its Wrong Datafor Next Operation consequence as follows: Wrong Value - CWEs: 129, 170, 606, 781, 1285, and 1289; Inconsistent Value - CWEs: 130, 230, 232, and 1288; Wrong Type - CWEs: 1284, and 1287."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONAll relationships to input, output, and injection CWEs by BF DVL and BF DVR consequences are asfollows:4) The following CWEs reflect only DVL or DVR causes:102, 105, 106, 108, 109, 183, 184, 185, 186, 228, 229,231, 233, 234, 235, 236, 237, 238, 239, 240, 554, 625,1173, and 1174."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONThe BF Data Check Bugs classes present a taxonomywith structured cause/consequence relations that is completeand orthogonal. It could be viewed as a structured extensionover the CWEs related to Injection Errors, Invalid Data,Wrong Value, Inconsistent Value, and Wrong Type. Itis a taxonomy that explains the causal relationships betweenweaknesses and would be easier to use than the nestedhierarchical CWEs."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONMany bug reporting tools use the CWE to describe found bugs/weaknesses. As a structured extensionover the input, output, and injection CWEs, the BF DataCheck taxonomy can be used to report found data checkbugs/weaknesses (including those leading to injection errors)."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VI. SHOWCASESIn this section, we use the new BF Data Check Bugsclasses for precise descriptions of real-world software vulnerabilities. We also provide the real-world fixes of each bug."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VI. SHOWCASESA. CVE-2020-5902 - BIG-IP TMUI RCEThis vulnerability is listed in CVE-2020-5902. It wasone of the top routinely exploited vulnerabilities in 2020 .It was identified by Mikhail Klyuchnikov.1) Brief Description: BIG-IP is a family of server-sideproducts from F5 Inc. focused on availability, performance,and security. In several versions, its Traffic ManagementInterface (TMUI), known as the BIG-IP Configuration utility,allows Remote Code Execution (RCE).2) Analysis: TMUI of BIG-IP accepts /..;/ via thelogin interface /tmui/login.jsp. However, the ApacheTomcat treats /..;/ as /../, which is a relative pathfor going one directory up. This allows a malicious user tobypass authentication, save and open files, and run arbitrarycommands on the host..3) The Fix: To fix the bug, input validation (e.g., viathe "".*\.\.;.*"" regular expression) should be added toreject any /..;/ elements."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VI. SHOWCASESB. CVE-2019-10748 - Sequelize SQL InjectionThis vulnerability is listed in CVE-2019-10748. It wasdiscovered by the Snyk Security Team.1) Brief Description: Sequelize is an Object-RelationalMapper for Node.js. It supports Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server; it facilitates transaction support, relations, and lazy loading [19]. In severalversions query-generator.js allows SQL injection.2) Analysis: User input path is not sanitized forMySQL/MariaDB syntax in a JSON (JavaScript Object Notation) object. 3) The Fix: To fix the bug, the developers check theinput paths syntax and sanitize it."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VI. SHOWCASESC. CVE-2014-0160 - Heartbleed Buffer OverflowThis vulnerability is listed in CVE-2014-0160.Heartbleed is using the BF MAD (Memory Addressing Bugs) and the BF MUS (MemoryUse Bugs) classes. Here we complete the BF taxonomy forHeartbleed by describing the DVR bug that starts the chainof weaknesses leading to buffer overflow.1) Brief Description: Heartbleed is a vulnerability dueto a bug in the OpenSSL that allows a server to read over thebounds of a buffer. Using the heartbeat extension tests in TLS(Transport Layer Security) and DTLS (Datagram TransportLayer Security) protocols, a user can send a heartbeat requestto a server. The request contains a string and a payloadunsigned integer, which value is expected to be the stringsize but could be as big as 65535.2) Analysis3) The Fix: To fix the bug, the OpenSSL team added avalue verification for the array size."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VII. RELATED WORKSIn this work, we introduce BF's new classes for datavalidation and data verification bugs. They can be used todescribe input data check bugs that lead to injection errors orto improper (e.g., inconsistent) data that would cause othersoftware errors (e.g., buffer overflow)."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VII. RELATED WORKSSeveral authors attempted to create successful taxonomies of bugs/weaknesses that lead to security failures. Data validation (usually called parameter or input validation) is a commoncategory across the different taxonomies reviewed by them.The new BF Data Check Bugs taxonomy differs from any ofthese taxonomies as it allows describing how a security failureemerges from a bug by a chain of weaknesses. For a bug toexist, there should be a particular cause leading to a particularconsequence. In BF, the kinds of causes relate either toimproper operations or to improper operands. The causeof one weakness could be the consequence of a previousweakness. This chain of weaknesses eventually ends in asoftware error that leads to a security failure. This approachclearly explains, for example, that the well-known Heartbleedvulnerability starts with a Data Verification Bug, which leadsto memory-related weaknesses, ending in a buffer overflowerror. Using any of the reviewed taxonomies, it would notbe possible to describe and understand the interrelationshipbetween weaknesses nor how the failure (e.g., exposure ofsensitive information in Heartbleed) emerges."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VII. RELATED WORKSRay and Ligatti formally define what they callcode injection on output (CIAO). The reasoning behind theirdefinition is that injection errors happen when untrusted inputpropagates unmodified to output. The CIAO definition isequivalent to the union of our definitions of query injection,command injection, and source code injection. All, exceptsome source code injections, are related to unchecked symbols that propagate from input to output."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VII. RELATED WORKSRay and Ligatti also define code interference attackson outputs (CIntAO). The reasoning behind their CAIntOdefinition is analogous to the reasoning for our ParameterInjection definition - maliciously inserted data causes anunexpected behavior that leads to a security failure.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VII. RELATED WORKSIn some sources/papers, the term ""codeinjection"" is used to describe an RCE failure, caused forexample, by buffer overflow. Although this kind of securityfailure is not caused by source code injection (as we havedefined it), for some buffer overflow errors a data verificationbug may be the first bug in the chain leading to that error(see Section VI-C). Using BF to describe such a vulnerability would help clearly separate source code injection from buffer overflow that leads to arbitrary code execution. This exemplifies how BF can help avoid confusion in vulnerability descriptions and improve communication about bugs, weaknesses, and the security failures caused by them."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VII. RELATED WORKSCurrently, several institutions provide lists of securitybugs/weaknesses. From these, we recognizethe MITRE CWE as the most widely known and used one.We discuss in Section V how BF extends the CWE exhaustivelist approach, as well as how to map CWEs to BF classes andextend the CWE based bug reports with BF descriptions."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VIII. CONCLUSIONIn this paper, we introduce two new BF classes: DataValidation Bugs (DVL) and Data Verification Bugs (DVR).We present their operations, possible causes, consequences,attributes, and sites. We show how they cover all CWEsrelated to input/output validation, verification, as well as toinjection. We analyze particular input data check and injectionvulnerabilities and provide their precise BF descriptions. TheBF structured taxonomies show the initial error in code(the bug), providing a quite concise and still far more cleardescription than the unstructured explanations in currentrepositories, advisories, and publications. The BF Data CheckBugs taxonomy can be used by bug reporting tools, as it isa structured extension over the input, output, and injectionrelated CWEs. To our knowledge there is no other bug taxonomy that allows precise causal descriptions of datavalidation and data verification bugs/weaknesses."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VIII. CONCLUSIONFuture work should identify and describe more CVEs related to data validation and data verification bugs/weaknesses,evaluating the BF Data Check Bugs taxonomy for usability. Insuch an evaluation, a machine learning algorithm or multipleanalysts would classify and describe newly reported bugs, while helping improve BF's taxonomy by fine-tuningthe classes."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VIII. CONCLUSIONThe CWE digraphs by BF class consequences should bedeeply analyzed. Generation of digraphs with CWEs relatedto particular software errors (e.g., injection errors), detectingcorresponding clusters, and understanding their relationshipswould create a comprehensive view of the CWE modelfor researchers and practitioners. In turn, comparing andcontrasting the CWE's exhaustive list of weaknesses with allthe possible consequence-cause transitions to other BF classeswould improve BF as a tool for describing CVEs."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VIII. CONCLUSIONWe will continue developing orthogonal BF classes thatcover and extend the CWE weakness types.
