text
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- ABSTRACTThe Common Weakness Enumeration (CWE) community publishes an aggregate metric to calculatethe 'Most Dangerous Software Errors.' However, the used equation highly biases frequency overexploitability and impact. We provide a metric to mitigate this bias and discuss the most significantsoftware weaknesses over the last ten years."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- IntroductionIn 2020, there were over 18 000 documented software vulnerabilities that enable malicious activity. While manyare discovered, they map to a relatively small set of underlying weakness types. We posit that if the most significant of these types can be identified, developers of programming languages, software, and security tools can focus on preventing them and thus, over time, diminish the quantity and severity of newly discovered vulnerabilities. We define a 'significant' weakness as one that is both frequently occurring among the set of publicly published vulnerabilities and results in high severity vulnerabilities (those that are easily exploitable and have high impact). The set of security weakness types upon which we calculate significance comes from the Common Weakness Enumeration (CWE)."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- IntroductionIn the fall of 2019, the CWE community published an equation to calculate the ""Top 25 Most Dangerous SoftwareErrors"" (MDSE) among the set of CWEs. It follows the form of the standard security risk matrix combiningprobability/frequency and severity."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- IntroductionThe MDSE equation claims to combine 'the frequency that a CWE is the root cause of a vulnerability with theprojected severity'; the equation description implies that both factors are weighed equally (making no mention of any bias). However, we empirically found that the equation highly biases frequency and almost ignores severity in generating top lists of varying sizes. This is due to the equation multiplying calculated frequency and severity values together though each has very different distributions. Frequency distributions have a power-law like curve, while severity distributions are more uniform. Our mitigation is to create a revised equation, named MSSW, that adjusts the frequency distribution using a double log function to better match it to the severity distribution."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Cybersecurity vulnerabilitiesWe can define a vulnerability as a weakness, in the security of a system, that can be exploited. The Common Vulnerabilities and Exposures (CVE) is a large set of publicly disclosed vulnerabilities in widely-used software. They are enumerated with a unique identifier, described, and referenced with external advisories."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Cybersecurity vulnerabilities Scoring vulnerabilities severityThe Common Vulnerability Scoring System (CVSS) 'provides a way to capture the principal characteristics of avulnerability and produce a numerical score reflecting its severity'. The CVSS base score takes into account the exploitability (how easy it is to use the vulnerability in an attack) and impact (how much damage the vulnerability can cause to an affected component) of a vulnerability apart from any specific environment.The exploitability score is determined by the following: attack vector: 'the context by which vulnerability exploitation is possible', attack complexity: 'the conditions beyond the attacker's control that must exist in order to exploit the vulnerability', privileges required: 'the level of privileges an attacker must possess before successfully exploiting the vulnerability', and user interaction: a human victim must participate for the vulnerability to be exploited."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Cybersecurity vulnerabilities Scoring vulnerabilities severityThe impact score is determined by measuring the impact to the confidentiality, integrity, and availability of the affectedsystem. Also included is a scope metric that 'captures whether a vulnerability in one vulnerable component impactsresources in components beyond its security scope'."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Cybersecurity vulnerabilities Weaknesses: Classifying vulnerabilitiesWhile we define a vulnerability in terms of a weakness, it is hard to define a weakness itself. As different vulnerabilities may be associated with the same weakness type, we could look at a weakness type as a class and a vulnerability as an instance of that class. Although it is uncommon, a single vulnerability could be associated with two or more weaknesses exploited sequentially or in parallel. In that sense, a vulnerability is a set with one or more instances of weaknesses."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Cybersecurity vulnerabilities Weaknesses: Classifying vulnerabilitiesThe Common Weakness Enumeration (CWE) is a 'community-developed list of common software security weaknesses'. It contains an enumeration, descriptions, and references for 839 software weaknesses that are referred to as CWEs, where each is labelled CWE-X with X being an integer."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Cybersecurity vulnerabilities Weaknesses: Classifying vulnerabilitiesThe CWE weaknesses model has four layers of abstraction: pillar, class, base, and variant. There is also the notion of a compound, that associates two or more interacting or co-occurring CWEs. These abstractions reflect to what extent issues are described in terms of five dimensions: behavior, property, technology, language, and resource. Variant weaknesses are at the most specific level of abstraction; they describe at least three dimensions. Base weaknesses are more abstract than variants and more specific than classes; they describe two to three dimensions. Class weaknesses are very abstract; they describe one to two dimensions, typically not specific about any language or technology. Pillar weaknesses are the highest level of abstraction."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Cybersecurity vulnerabilities Weaknesses: Classifying vulnerabilitiesThere are a set of taxonomies, called views, to help organize the CWEs. Two prominent CWE taxonomies are the'Research Concepts' (view 1000) and 'Development Concepts'. There is also the 'CWE Weaknesses forSimplified Mapping of Published Vulnerabilities View' that was made to describe the set of CVEs; it contains 127 CWEs."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Cybersecurity vulnerabilities Binding CVEs, CWEs, and CVSSThe National Vulnerability Database (NVD) offers a public database that maps all CVE entries to CWEs and CVSS scores. For each CVE it provides a CVSS score along with the applicable CWE(s) that describe the weakness(es) enabling the vulnerability. The NVD data is the cornerstone of this work, enabling the analysis of the most significant CWEs over the last ten years."
A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MDSE scoreThe MDSE equation was designed to balance the frequency and severity in ranking the CWEs. The frequency isdetermined by the number of CVEs that map to a given CWE in the time period of study. The severity is determined by the mean CVSS score for the CVEs mapped to a given CWE. The MDSE score for a CWE is produced by multiplying the normalized frequency by the normalized severity and then multiplying by 100.
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MDSE score Limitation 1: Distribution DifferencesThe MDSE score then appears to equally include both frequency and severity. However, we empirically find that the MDSE equation strongly biases frequency over severity. The MDSE equation in practice biases frequency over severity, even though its equation treats them equally, because frequency and severity have very different distributions. This can be illustrated by the analysis of 2019. The frequency distribution has the majority of CWEs at a very low frequency and a few at a very high frequency (somewhat resembling a power law curve).The severity distribution is more uniform within a limited range."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MDSE score  Limitation 2: Normalization Error The normalization of the CVSS score does not lead to the expected and desired normalized distribution from 0 to 1. For our data the range is from .28 to .97. The reason for this is that the mean of the CVSS score for the CVEs that map to a particular CWE has a smaller range than the maximum and minimum CVSS score. This limitation, while of less consequence than the previous, constrains the range of Si values thus further lessening the influence that severity has in determining a MDSE score."
A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MSSW scoreOur goal is to mitigate the limitations of the MDSE equation.
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MSSW score  Addressing the MDSE's limitationsTo address MDSE limitation 1, we propose a linearization for the normalized frequency. This proposal represent a behavior which create large differences between the most frequent CWEs and almost no difference between the infrequent CWEs.'"
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MSSW score  Addressing the MDSE's limitationsThus, we apply a double log for further linearization. We note that this approach is not pseudo-linear for the most infrequent of CWEs. However, this does not cause problems as our goal is to identify the most significant and any such CWE must have at least a moderate frequency."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MSSW score  Addressing the MDSE's limitationsThe MSSW equation then multiplies frequency and severity as in the original MDSE equation. However, it multiplies from two distributions with a similar shape for the part of the functions that are of interest. This enables the MSSW equation to more fairly balance frequency and severity in scoring and ranking a CWE."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MSSW score  Addressing the MDSE's limitationsTo address MDSE limitation 2, the MSSW normalizes the severity using the maximum and minimum mean severityvalues. This gives the distribution a full 0 to 1 range, which is not achieved in the MDSE equation."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MSSW score  Analyzing the MSSWWe evaluate the effect of the MSSW equation in making the frequency and severity distributions more similar, producing a score with more equal inclusion of both frequency and severity."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MSSW score  Analyzing the MSSWNoticeable is how the MSSW equation chooses CWEs for the top 20 list from CWEs with generally higher CVSS scores. However, it excludes many high severity CWEs because their frequencies were too low."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- The MSSW score  Analyzing the MSSWNote that our usage of the double log reflects the nature of the data (observed frequencies) and the desire to fairly balance evaluating frequency and severity in the MDSE equation. If the frequencies had created a different distribution, another ""linearization"" function would potentially have been better justified. Our main finding is that the MDSE will likely be (and currently is) biased toward one of the parameters (frequency or severity) depending on their relative distributions."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical AnalysisWe use our improved scoring equation (MSSW) to perform a historical study of the most significant weaknesses over the ten-year period of 2011 to 2020. To do so, we collected the 10 CWEs with the highest MSSW value for each year and ranked them in descending order. Our analysis of these lists informs us about the evolution of the software weaknesses landscape so that we can determine if it is changing or static. Our finding is that a similar set of CWEs occupy the Top 10 lists each year and those CWEs can be grouped into an even smaller set of weakness types. "
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical AnalysisIt can be observed that this indicates the weaknesses landscape has been dominated by only a few weakness types; it is due to the same CWEs occurring in the Top 10 lists each year. Among the 88 possible BVC CWEs, only 19 have appeared in the Top 10 lists for the last 10 years (11 of which have appeared at least 5 times). Similarly, among the 39 possible PC CWEs, only 17 have appeared in the Top 10 lists for the same period (9 of which have appeared at least 5 times). These results show that a minority subset of CWEs have dominated the Top 10 lists for the last decade; from this vantage point the software weaknesses landscape is practically not changing. Instead of seeing a diversity of CWEs entering the Top 10 lists, the same kinds of weaknesses reappear year after year."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical AnalysisTwo groups of weaknesses dominate the Top 10 lists: injection and memory errors.These include CWEs that are related to file management, data authenticity, authentication, and integer arithmetic which we have put in one group, 'Other CWEs'."
A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical AnalysisOne can observe that a consistent increase in the sum of the MSSW scores of all Top 10 BVC CWEs duringthe last ten years. This represents a shift where a subset of CWEs increasingly become both the most frequent and impactful. Note that this is not due to simply an increase in the number of vulnerabilities discovered because both frequency and impact are normalized within MSSW. One explanation for this trend could simply be that attackers are increasingly leveraging CWEs that give them the greatest influence on targeted systems.
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical AnalysisInjection and memory corruption CWEs follow this trend of increasing MSSW scores and they dominate the Top 10lists. We can observe that after 2017, all the five most dangerous CWEs are either injection or memory corruption. After 2019, only 2 CWEs are outside of those groups in the BVC Top 10 lists. This explains the increase of the MSSW score sum for injection and memory corruption CWEs and the decrease of the MSSW score sum for other CWEs."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical Analysis Injection and Memory Corruption: The Most Dangerous WeaknessesWe now look more closely at these 2 top CWE groupings. An injection bug happens when an unsanitized input isassembled, added, or inserted in a code fragment or in a command, forming an invalid construct that is not supposed to be executed. "
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical Analysis Injection and Memory Corruption: The Most Dangerous WeaknessesThe three most dangerous CWEs form the MSSW Top 10 Base/Variant/Component: CWE-89, CWE-78, and CWE-94. Theyall appear with very high MSSW scores every year. SQL Injection is by far the most dangerous weakness in ouranalysis. It is consistently the number one weakness in every Top 10 BVC list, with an average MSSW score of 76.6. It contributes to the class CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component). OS Command Injection is the second most dangerous injection weakness. It appears in every Top 10 BVC list except for 2011 and 2016, with an average MSSW score of 75.18. It is also a contributor to CWE-74 and a contributor to CWE-77 (Improper Neutralization of Special Elements used in a Command ('Command Injection'). Code Injection appears in every Top 10 BVC list except 2012, 2014, and 2017, with an average MSSW score of 66.9. It is also a contributor to CWE-74 and a contributor to CWE-913 (Improper Control of Dynamically-Managed Code Resources). Interestingly, CWE-74 has a light grey circle in The MSSW Top 10 Pillar/Class, while its children base CWE-89, 78, and 94 have very dark ovals in MSSW Top 10 Base/Variant/Component. This happens because CWE-74 is also parent of several CWEs that are either very infrequent or nonsevere."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical Analysis Injection and Memory Corruption: The Most Dangerous WeaknessesDeserialization of untrusted data (CWE-502) is a considerably new injection weakness. It appears in the BVC Top 10 list in all years after 2016 with a high average MSSW score of 72.6. The exploitation of deserialization bugs was leveraged after November 2015, when Foxglove Security published their exploits for the Java deserialization weakness."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical Analysis Injection and Memory Corruption: The Most Dangerous WeaknessesA memory corruption bug happens when data stored in memory is unintentionally modified. This could happen during memory allocation, deallocation, and use (read and write data). In The MSSW Top 10 Base/Variant/Component, the memory corruption weaknesses are CWE-787 (Out-of-bounds Write), CWE-120 (Classic Buffer Overflow), CWE-416 (Use After Free), and CWE-476 (NULL Pointer Dereference). Out-of-bounds Write is the most dangerous memory corruption weakness. It appears in every Top 10 BVC list except for 2011 and 2015, with an average MSSW score of 70.8. The class CWE-119 is a general memory corruption weakness, which includes use after free and double free. All memory CWEs on the Top 10 lists contribute to the class CWE-119, except CWE-476, contributing to CWE-672. Due to its broad scope, CWE-672 is also the parent of CWE-613."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical Analysis Injection and Memory Corruption: The Most Dangerous WeaknessesSQL Injection and OS Command injection weaknesses have a higher average MSSW score than that of any otherweaknesses. The related CVEs analysis confirms that the injection CVEs are easier to exploit and have a higherimpact. An injection directly leads to arbitrary command, code, or script execution. Once a SQL injection is in place, there is no need of an additional sophisticated attack crafting or use of glitches in the system. In contrast, it takes considerable extra effort for an attacker to turn a buffer overflow into an arbitrary code execution. The possible damage from a SQL injection is also very high. It may expose vast amounts of structured data, which is generally more valuable than raw data. Well-formed structured data is easy to read, sort, search, and make sense of. An attacker could modify a database - insert data, update data, delete data, execute admin operations, recover file content, and even issue OS commands to the operating system."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- Historical Analysis Mapping DependenciesOur historical analysis heavily depends on how NVD assigns CWEs to particular CVEs and it is not always possible for this mapping to be done perfectly. The CWE selection is restricted to view CWE-1003. The lack of enough information about a CVE or the lack of a more specific CWE may lead to the CVE described with the closest class CWE or even with a pillar CWE. For example, it makes sense for class CWE-119 to be used for the memory corruption CVE-2019-7098, as there is not much information, no code nor details about it - it could be any memory use error or a double free. However, there is enough information about the use after free CVE-2019-15554, and it still gets described with class CWE-119, as there is no appropriate base CWE. A close base CWE is CWE-416 (Use After Free), but it does not really reflect memory-safe languages like Rust. It is also possible for a class CWE to be assigned to a CVE even when a specific base CWE is available. For example, the stack buffer overflow write CVE-2019-14363 is assigned class CWE-119, although there is plenty of information and appropriate bases CWE-121 and CWE-120."
A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- No Ground TruthThe constant need to improve information security has motivated a widespread interest in metrics. As Lord Kelvin's famous quote suggests: you cannot improve if you cannot measure.
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- No Ground TruthIn hard sciences, such as physics and chemistry, a measurement is an experimental procedure that compares a quantity against a well-defined standard. A measurement must be reproducible, allowing results comparison over different conditions, such as using different measuring systems. It allows the claim that a measurement result is wrong by showing that it disagrees with other measurements (i.e., irreproducible)."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- No Ground TruthIn software security, we lack not only experimental procedures and stable standards. We are in a much earlier stage of science, where we struggle to agree on the quantities to measure. There are members of the software security community who doubt that security can be measured. They argue that software security metrics may be infeasible, be difficult to validate, not be justified with empirical data, and contain formal treatments adopted from other fields that don't map well to operational security."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- No Ground TruthWe understand that, at least for now, there is no ground truth, and the science of security is still in its early days.However, we posit that acceptable but possibly imperfect metrics must be developed in order to facilitate security decisions and to evaluate changes in security posture. To this end, there have been substantial efforts to produce security metrics; surveys the literature of security metrics published between 1981 and 2008. Specific to software security, there is the OWASP Top 10 for web applications. Also, the CWE project has the Common Weaknesses Scoring System (CWSS) and the Common Weakness Risk Analysis Framework (CWRAF), which are used together to provide the most important weaknesses tailored to a particular organization."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- No Ground TruthGiven that there is no ground truth upon which to justify how to best combine frequency and severity or to establish the CVSS metric's correctness, it is likely impossible to prove any such metric as maximally effective. We make our 'most accurate measurement yet' claim based on the demonstrated limitations in the published MDSE equation and a lack of competing published alternatives. Along with much other work, we believe that our contribution is significant. It points out a severe bias in the CWE MDSE equation that prevents accurate measurements of the most significant software security weaknesses."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- ConclusionSecurity metrics are a challenging scientific research area, because there is often no ground truth, unlike physics and chemistry. This may lead one to focus on just taking simple low-level measurements that are inherently defensible; that was the approach taken in. However, creating aggregate metrics that compose multiple simple measurements is of practical importance for the field of security. In this work, we did just that, aggregating frequency and severity (i.e., exploitability and impact) into a single metric. Our objective was not for the correlations to necessarily be equal, but that there is a strong correlation for both factors that more evenly balance the inclusion of the top frequency and top severity CWEs."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- ConclusionUsing the proposed equation we explore the software weaknesses landscape. We observed that in 10 years, the same types of weaknesses have been dominating the threat landscape and not much has changed. Through the lens of the metrics in this paper we aren't making progress. We believe that the security community needs new approaches. We would prefer not to write this same paper 10 years from now showing that, once again, not much has changed."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- ConclusionIt is challenging to catch up with hackers; they need to find only one weak spot, while we (the community) have to defend entire systems. New doors also get opened (e.g., in recent years Object Deserialization injection). Nevertheless, the results of this study show that either we are incapable of correcting the most common software flaws, or we are focusing on the wrong ones. Although this paper is not making a definite conclusion, the comparison with the historical analysis based on the biased MDSE suggests that it is rather the latter. In either case, it seems to us that there is a need to ""stop and think"" about the ways we are developing software and/or the methods we use to describe and identify vulnerabilities. A new unambiguous classification of software weaknesses that allows clear structured descriptions of security vulnerabilities would be a first step. That would allow formalization and automatization of weaknesses identification and vulnerabilities mitigation. Operationally, more software development languages and tools need to be developed and/or promoted that automatically prevent or remediate commonly identified software weakness."
"A DECADE OF REOCCURRING SOFTWARE WEAKNESSES- AcknowledgmentThis work was partially accomplished under NIST Cooperative Agreement No.70NANB19H063 with PrometheusComputing, LLC. The authors would like to thank the NVD staff for their review and consideration of this work."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -Abstract In this work, we define the notions of software bug, weakness, and vulnerability in the context of cybersecurity and elucidate their causal relations."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -Abstract Security vulnerabilities lead to failures that are commonly used to attack cyberspace and thecritical infrastructure. Communicating about them, however, even security experts use loosely thenotions of bug, fault, weakness, vulnerability, and failure. For example, artificial intelligence (AI) chatbots are trained on input from all over the Internet including misunderstandings. Subsequently, conflating explanations about these concepts resurface, providing a glimpse on how software security concepts are used in publications, security advisories, and testing tool reports."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -Abstract Building a common language that avoids conflation, synonymy, and polysemy is a critical challenge in systems engineering. This is also true for cybersecurity. For example, misunderstanding the root cause is acritical factor for reopening fixed bugs, and the lack of clearly defined concepts hinders the automaticprocessing of security-related information."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -Abstract In this paper, we clearly define the software security terms bug, fault, error, weakness, vulnerability,and failure, as part of our work on the NIST Bugs Framework (BF). Starting from vulnerability, we gotowards weakness, bug, and fault, and then towards error, final error, and failure. We model a softwaresecurity vulnerability as a chain of weaknesses that leads to a security failure. A security bug causes thefirst weakness, leading to an error. This error becomes the cause (for example the fault) for a next weakness and propagates through subsequent weaknesses until a final error is reached, causing the security failure."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -DEFINITIONSA broad spectrum of software security researchers and practitioners would benefit from clear definitions of the terms bug, fault, error, weakness, vulnerability and failure in the context of software security."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -DEFINITIONSWe can observe that a security vulnerability leads to a security failure. However, what are the buildingblocks of a vulnerability? What is the defect in software that triggers a vulnerability? How does it propagate through errors until a final, exploitable error is reached? How do the underlying weaknesses of a vulnerability relate to these propagating errors?"
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -DEFINITIONSA software security vulnerability is a chain of weaknesses linked by causality. It starts with a bug and ends with a final error, which if exploited leads to a security failure."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -DEFINITIONSA software security weakness is a (bug, operation, error) or (fault, operation, error) triple. It is an instance of a weakness type that relates to a distinct phase of software execution, the operations specific for that phase and the operands required as input to those operations."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -DEFINITIONSA software security bug is a code or specification defect - an operation defect."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -DEFINITIONSA software fault is a name, data, type, address or size error - an operand error. Name is in referenceto a resolved or bound object, function, data type or namespace. The others are in reference to an object."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -DEFINITIONSA software error is the result from an operation with a bug or a faulty operand. It becomes a next fault oris a final error."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -DEFINITIONSA software security final error is an exploitable or undefined system behavior that leads to a security failure."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -DEFINITIONSA security failure is a violation of a system security requirement."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -DEFINITIONSA chain of weaknesses starts with a bug, propagates through errors that become faults, and ends witha final error. The final error is the one exploited by attackers towards a security failure. For example, missing input validation may propagate to integer overflow, followed by buffer overflow, which if exploited may lead to a remote code execution failure."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -DEFINITIONSThe bug must be fixed to resolve the vulnerability; while, in most cases, fixing a fault would only mitigatethe vulnerability. To fix a bug (code or specification defect), lines of code or configuration files, etc., must be changed. The bug is a concrete error; it is a wrong sequence of bits that must be changed. Fixing a specification is also code related, as it requires fixing its implementation."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -DEFINITIONSA security failure may be caused by the converging final errors of several vulnerabilities. The bug in at least one of the chains must be fixed to avoid the failure."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -VULNERABILITY MODELThe BF software security vulnerability mode presents our BF software security vulnerability model. Following the definitions of weakness, bug, operation, error, and final error and our formal grammar, a vulnerability description uses causal relations to form a chain of underlying weaknesses, leading to a failure."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -VULNERABILITY MODELEach weakness is an instance of a weakness type with a particular bug or fault as a cause and an erroras a consequence. The error establishes a transition to another weakness or a failure."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -VULNERABILITY MODELA bug always causes the first weakness in a chain of weaknesses; it is a coding or specification defect, which, if fixed, will resolve the vulnerability. A fault causes each intermediate state. The last weakness always ends with a final error (undefined or exploitable system behavior) that causes the failure (a violation of a system security requirement)."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -VULNERABILITY MODELA transition is the result of the operation over the operands. For example, in the BF software security vulnerability model, Operation 1 from the first weakness has a Bug and results in Error 1, which becomes the fault for operation 2, leading to Error 2. The chain goes on, until the last operation results in a Final Error, leading to a failure."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -VULNERABILITY MODELTherefore, a vulnerability can be described precisely as a chain of weaknesses and their transitions.This chain is a sequence of improper states in the vulnerable software."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -VULNERABILITY MODELEach improper state is an instance of a weakness type, corresponding to a Bugs Framework (BF) class. The transition from the initial state is by improper operation (an operation that has a bug) over proper operands. The transitions from intermediate states are by proper operations with at least one improper operand (the operand is at fault)."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -VULNERABILITY MODELIn some cases, several vulnerabilities must be present for an exploit to be harmful. The final errorsresulting from different chains converge to cause a failure. The bug in at least one of the chains must be fixed to avoid that failure."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -EXAMPLELet's look at BadAlloc, a pattern discovered by Microsoft researchers and reported by the Cybersecurity and Infrastructure Security Agency (CISA) with 25 similar vulnerabilities found in multiple IoT devices."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -EXAMPLEThe BadAlloc vulnerability pattern comprises five consecutive weaknesses (see the BF BadAlloc chain as in CVE-2021-21834). The first weakness occurs at the data verification phase of software execution. There is a bug, such as missing code for checking data towards allowed numerical values, creating a data verification weakness. This allows input of an unusually large number 2 , which causes a wraparound error when performing arithmetic calculations (a type computation weakness). This error results in a smaller number being used for memory allocation, leading to not enough memory reserved for a buffer (a memory allocation weakness). This allows a pointer to move outside the buffer boundaries (a memory addressing weakness) and cause a buffer overflow final error while writing data there (a memory use weakness). The final error then can lead to a failure, such as denial of service or remote code execution."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -EXAMPLEThe BF BadAlloc chain presents the chain of weaknesses, underlying the particular BadAlloc vulnerability CVE-2021-21834."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -DISCUSSIONExplanations generated by ChatGPT about particular software security notions depend on the dialog, but it isastonishing how wrong they could be to start with. For example, the result from a question that asks an explanation of software security bug and weakness states a security bug is ""an error, a flaw, a failure, or a fault"" that ""causes incorrect or unexpected results"" and ""creates a security vulnerability"". It then plays with the common understanding of vulnerability instead of explaining weakness, except it adds a ""weakness is a defect or problem in the design of a piece of software"". While a bug is not a failure, a weakness is not a vulnerability defect relates to bug, and fault relates to error. The results support our own research conclusion that cleardefinitions of all these notions are greatly needed."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -DISCUSSIONOur vulnerability model (BF software security vulnerability model) and definitions can be used on a high enough abstract level to describe the weakness pattern for several vulnerabilities -for example the BadAlloc pattern. However, they are also concrete enough to provide details on the weaknesses underlying a particular vulnerability - for example the CVE-2021-21834 chain. Our approach allows to reveal how same types of weakness chain to form different vulnerabilities and how a particular bug in a piece of code leads to a failure."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -DISCUSSIONUnderstanding the role of faults as propagating errors in a chain of weaknesses, makes it easier tosee that the final error of a vulnerability is the one that gets exploited. Recall the BadAlloc pattern and the CVE-2021-21834 description adherent to our vulnerability model: an unverified large input to a calculation at buffer allocation causes use of a wrapped-around value as size, leading to a smaller buffer and allowing overbound writes. First and more importantly, we learn about the vulnerability severity: a write buffer overflow may crash the system or, even worse, allow remote code execution. Next, we learn what should be fixed to resolve the vulnerability: the missing input verification bug. Last, we can reason about in-depth defense measures to mitigate the vulnerability. For example, use of address space layout randomization to mitigate buffer overflow on dynamically allocated memory or safe integer libraries to mitigate wrap-around errors. Understanding the chain of weaknesses allows better development, defense, and mitigation decisions. It would be misleading to say CVE-2021-21834 has a buffer overflow bug or is a buffer overflow failure. Much would be missing also if we only say it has a buffer overflow weakness."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -DISCUSSIONNote that the BF vulnerability model focuses on weaknesses within software. Embedding it in attackspecific models (for example  NIST Vulntology), would allow external causes, such as hardware failures, systemmisconfigurations, interactions with other software, or human interactions."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -RELATED WORKIn this section, we compare and contrast our BF vulnerability model with related works."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -RELATED WORKR. Chillarege, I. S. Bhandari, J. K. Chaar introduce the idea of causal, orthogonal classification of defects. Our definition of bug parallels their definition of defect. However, we delve deeper and differentiate the initial defect (the bug) from the propagated errors (the faults). We define all the concepts on a level of abstraction that would help clear explanation of a causal chain from the bug through faults to the eventual security failure. Facilitating clear communication about security vulnerabilities is our main goal. Our approach, however, by its nature, may also allow automated backtracking to the bug."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -RELATED WORKThe reliability community has also struggled to define the concepts of software defect, fault, error, andfailure. Several papers from the 90's discuss these concepts. Some found the hardware analogy tempting, but it had limits and it was found confusing. Instead, we build our definitions from the notion of software security vulnerability as the cause of security failure (for example loss of a security property). The failure is triggered by a software security bug unintended functionality that breaks basic security principles."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -RELATED WORKA. Avizienis, J.-C. Laprie, B. Randell, and C. Landwehr define security faults, errors,and failures using causal relationships. They explain that errors propagate inside components from an initial fault until a failure is reached. Their definitions of fault as ""the adjudged or hypothesized cause of an error"" and error as ""a part of a system's total state that may lead to a failure"" reflects our understanding of bug and fault. We also reason a fault is a cause for an error, but in addition we deem recurrence essential to explain better how errors propagate in software. For example, an erroneous result of an operation could be a faulty cause for a next operation. We define the bug as the cause of error from the initial improper state, propagating through errors from intermediate states, towards the error from the final state, which leads to a failure. They state that error propagation is through thecomputation process, however, they do not delve as deep as we do. We bring up the concept of operation(and its operands) to explain how an error, resulting from a bug or fault, transitions into the fault, causing another error. We state a vulnerability is underlined by a chain of weaknesses, each corresponding to a particular bug or fault and a particular operation that results in an error. The notion of transition is important as the error resulting from a weakness can be more abstract than the concrete fault of a next weakness."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -CONCLUSIONIn this paper, we define the fundamental notions of security failure and software security vulnerability, weakness, bug, and final error; and detail the definitions of software fault and error. We have developed them iteratively, while creating the NIST Bugs Framework (BF) software security vulnerability model. They help us reason about and create weakness taxonomies, allowing precise descriptions of existing vulnerabilities."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -CONCLUSIONA broad spectrum of information technology (IT) managers, software developers, and security researchers would benefit from a clear understanding of these terms in the context of software security. Accurate understanding of underlying weaknesses would ensure proper bug identification, which could improvefixing times and decrease chances of introducing new bugs via patches. Formalized definitions would assistin machine processing of security-related information and in generating software testing reports."
"Bug, Fault, Error, or Weakness: Demystifying Software Security Vulnerabilities -CONCLUSIONThe results from ChatGPT queries show we must rely on more than just AI to discern concepts. Underthe ChatGPT's hood lays a model that learns from all over the Internet, including misunderstandings. In parallel to the ancient Oracle of Delphi, the caller should be well prepared to provide the right questions and context; otherwise, the reasoning may be misleading and the result disastrous. Using our software security expertise to pose more and more tuned questions, thus providing more context, eventually we got ChatGPT to at least partially discern our own reasoning. The collective knowledge seems to approve the direction we are delving in via our BF research."
"Classifying Memory Bugs Using Bugs Framework Approach- ABSTRACT In this work, we present an orthogonal classification of memory corruption bugs, allowing precise structureddescriptions of related software vulnerabilities. The CommonWeakness Enumeration (CWE) is a well-known and used list ofsoftware weaknesses. However, it's exhaustive list approach isprone to gaps and overlaps in coverage. Instead, we utilize theBugs Framework (BF) approach to define language-independentclasses that cover all possible kinds of memory corruptionbugs. Each class is a taxonomic category of a weakness type,defined by sets of operations, cause/consequence relations,and attributes. A BF description of a bug or a weaknessis an instance of a taxonomic BF class, with one operation,one cause, one consequence, and their attributes. Any memoryvulnerability then can be described as a chain of such instancesand their consequence-cause transitions. We showcase that BFis a classification system that extends the CWE, providing astructured way to precisely describe real world vulnerabilities. Itallows clear communication about software bugs and weaknessesand can help identify exploit mitigation techniques.Keywords are Bug classification, bug taxonomy, software vulnerability, software weakness, memory corruption."
"Classifying Memory Bugs Using Bugs Framework ApproachIn this paper, we first summarize the latest BF approachand methodology. Next, we analyze the types of memorycorruption bugs and define the BF Memory Bugs Model.Then, we present our BF memory bugs classes and showcasethey provide a better, structured way to describe CVE entries. We identify the corresponding clusters of memory corruption CWEs and their relations to the BF classes. Finally,we discuss the use of these new BF classes for identifyingexploit mitigation techniques."
"Classifying Memory Bugs Using Bugs Framework Approach- I. INTRODUCTIONSoftware bugs in memory allocation, use, and deallocation may lead to memory corruption and memory disclosure,opening doors for cyberattacks. Classifying them would allowprecise communication and help us teach about them, understand and identify them, and avoid security failures. For that,we utilize the Bug Framework (BF) approach ."
"Classifying Memory Bugs Using Bugs Framework Approach- I. INTRODUCTIONThe Common Weakness Enumeration (CWE) and theCommon Vulnerabilities and Exposures (CVE) are wellknown and used lists of software security weaknesses andvulnerabilities. However, the CWE's exhaustive list approachis prone to having gaps and overlaps in coverage, as demonstrated by the National Vulnerability Database (NVD) effortto link CVEs to appropriate CWEs . Instead, we utilize theBF approach to define four language-independent, orthogonalclasses that cover all possible kinds of memory relatedsoftware bugs and weaknesses: Memory Allocation Bugs(MAL), Memory Use Bugs (MUS), Memory DeallocationBugs (MDL), and Memory Addressing Bugs (MAD). ThisBF Memory Bugs taxonomy can be viewed as a structuredextension to the memory-related CWEs, allowing bug reporting tools to produce more detailed, precise, and unambiguousdescriptions of identified memory bugs."
"Classifying Memory Bugs Using Bugs Framework Approach- II. BF APPROACH AND METHODOLOGYBF's approach is different from CWE's exhaustive listapproach. BF is a classification. Each BF class is a taxonomiccategory of a weakness type. It relates to a distinct phase ofsoftware execution, the operations specific for that phase andthe operands required as input to those operations"
"Classifying Memory Bugs Using Bugs Framework Approach- II. BF APPROACH AND METHODOLOGYWe define a software bug as a coding error that needsto be fixed. A weakness is caused by a bug or ill-formeddata. A weakness type is also a meaningful notion, asdifferent vulnerabilities may have the same type of underlyingweaknesses. We define a vulnerability as an instance of aweakness type that leads to a security failure. It may havemore than one underlying weaknesses linked by causality."
"Classifying Memory Bugs Using Bugs Framework Approach- II. BF APPROACH AND METHODOLOGYBF describes a bug or a weakness as an improper stateand its transition. The transition is to another weaknessor to a failure. An improper state is defined by the tuple(operation, operand1,.., operandn), where at leastone element is improper. The initial state is always caused bya bug; a coding error within the operation, which if fixed willresolve the vulnerability. An intermediate state is caused byill-formed data; it has at least one improper operand. Rarelyan intermediate state may also have a bug, which if fixedwill also resolve the vulnerability. The final state, the failure,is caused by a final error (undefined or exploitable systembehavior), which usually directly relates to a CWE . Atransition is the result of the operation over the operands."
Classifying Memory Bugs Using Bugs Framework Approach- II. BF APPROACH AND METHODOLOGYBF describes a vulnerability as a chain of improperstates and their transitions. Each improper state is an instanceof a BF class. The transition from the initial state is byimproper operation over proper operands. The transitionsfrom intermediate states are by proper operations with at leastone improper operand.
"Classifying Memory Bugs Using Bugs Framework Approach- II. BF APPROACH AND METHODOLOGYIn some cases, several vulnerabilities have to be presentfor an exploit to be harmful. The final errors resulting fromdifferent chains converge to cause a failure. The bug in atleast one of the chains must be fixed to avoid that failure."
"Classifying Memory Bugs Using Bugs Framework Approach- II. BF APPROACH AND METHODOLOGYWe call a BF class the set of operations, the validcause/consequence relations for these operations, their attributes, and sites. The attributes are qualifiers for the operations and the operands that help understand how severe a bug is. The sites show where in code a bug might occur. The BFclasses are orthogonal by design; their sets of operations donot overlap."
"Classifying Memory Bugs Using Bugs Framework Approach- II. BF APPROACH AND METHODOLOGYThe taxonomy of a particular bug or weakness is basedon one BF class. Its description is an instance of a taxonomicBF class with one cause, one operation, one consequence, andtheir attributes. The operation binds the cause/consequencerelation - e.g., deallocation via a dangling pointer leads to afinal error known as double free."
Classifying Memory Bugs Using Bugs Framework Approach- II. BF APPROACH AND METHODOLOGYThe methodology for developing a BF class is as follows: (1) Identify the phase specific for a kind of bugs. (2)Identify the operations for that phase. (3) Define a BF bugsmodel showing operations flow. (4) Identify all causes. (5)Identify all consequences that propagate as a cause to a nextweakness. (6) Identify all consequences that are final errors.(7) Identify attributes useful to describe such a bug/weakness.(8) Identify possible sites in code.
"Classifying Memory Bugs Using Bugs Framework Approach- III. MEMORY BUGS MODELEach memory related bug or weakness involves onememory operation. Each operation is over a region of memory or over the address needed to reach it. That memory isused for storing data and has an important property: it isfinite. It has boundaries and it has size. We call this pieceof memory, with a well-defined size, an object. It is used tostore a primitive data or a data structure. The memory addressshould be held by at least one pointer or determined as anoffset on the stack, otherwise the object will be unreachable.The object and the pointer are the operands of that memoryoperation."
"Classifying Memory Bugs Using Bugs Framework Approach- III. MEMORY BUGS MODELMemory bugs could be introduced at any of the phasesof an object's lifecycle: address formation, allocation, use,and deallocation. The BF Memory Bugs Model helps identify where in these phases bugs could occur . Thephases correspond to the BF memory bugs classes: MemoryAddressing Bugs (MAD), Memory Allocation Bugs (MAL),Memory Use Bugs (MUS), and Memory Deallocation Bugs(MDL). All possible memory operations are grouped byphase. The presented operations flow helps in identifyingpossible chains of bugs/weaknesses."
"Classifying Memory Bugs Using Bugs Framework Approach- III. MEMORY BUGS MODELThe operations under MAD  are on formingor modifying a pointer: Initialize, Reposition, and Reassign.Bugs in pointer initialization could result in pointers to meaningless objects. Moving a pointer via a bugged Repositioncould get it pointing outside the object bounds. Bugs inReassign could connect a pointer to a wrong object."
"Classifying Memory Bugs Using Bugs Framework Approach- III. MEMORY BUGS MODELThe operations under MUS are on reading or writing thecontent of an object through one of its pointers: Initialize,Read, Write, Clear, and Dereference. Bugs in object initialization could lead to use of random or malicious data. Bugsin write could alter data wrongly. Bugs in Clear could leakconfidential information such as passwords and cryptographicprivate keys. Bugs in Dereference are practically unsuccessfulreading or unsuccessful writing. "
"Classifying Memory Bugs Using Bugs Framework Approach- III. MEMORY BUGS MODELThe operations under MAL are on creating an object orextending it through one of its pointers: Allocate, Extend,and Reallocate-Extend. The operations under MDL are on destroying or reducing anobject through one of its pointer: Deallocate, Reduce, andReallocate-Reduce. Both MAL and MDL operations affect the boundaries and the size of the object. Bugs in Reallocate may concern multiple pointers tothe same object. Allocation in excess or failure to deallocateunused objects could exhaust memory. Excessive reductionof allocated memory could lead to an object that is too littlefor the data it needs to store."
"Classifying Memory Bugs Using Bugs Framework Approach- III. MEMORY BUGS MODELThe very first operation is MAL Allocate an object. Following the green arrows, thefirst operation is MAD Initialize a pointer. Next operation,following the blue arrows, should be MAD Initialize thepointer to the address returned by Allocate. While, followingthe green arrows, next operation should be MAL Allocate anobject at the address the pointer holds."
"Classifying Memory Bugs Using Bugs Framework Approach- III. MEMORY BUGS MODELAfter an object is allocated and its pointer is initialized,it can be used via MUS Read or MUS Write. The boundariesand the size of an object are set at allocation, then they canbe changed by any MAL or MDL operation."
"Classifying Memory Bugs Using Bugs Framework Approach- III. MEMORY BUGS MODELIf an object is owned by more than one pointer, Reallocate (in MAL or MDL) should be followed by Repositionover all these owners. A Deallocate an object operationshould properly be followed by Reassign of all its pointersto either NULL or another object."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESWe define the BF Memory Bugs classes as follows:(a) MAD (Memory Addressing) which has 3 operation values such as Initialize(The first assign of an object address to a pointer,positions the pointer at the start of the object), Reposition (Changes the pointer to another position inside its object) and Reassign( Changes the pointer to a different object).(b) MAL (Memory Allocation) which has 3 operation values that Allocate (Reserves space in memory for an object; defines its initial boundaries and size), Extend(Allocates additional memory for an object in the same space,redefines its boundaries and size) and Reallocate-Extend (Allocates a new larger piece of memory for an object at a new address, copies the object content there, reassigns its,pointer, and deallocates the previous piece of memory)(c) MUS (Memory Use) which has 5 operation values that Initialize(The first write into an object, after it is allocated),Read(Gets content from an object), Write( Puts content into an object),Clear(The very last write into an object, before it is deallocated) and Dereference(e Overreaches Initialize, Read, Write, and Clear, focus is on object access, no matter if it's for reading or for writing)(d) MDL (Memory Deallocation) which has 3 operation values such as Deallocate(Releases the allocated memory of an object),Reduce(Deallocates part of the object memory; redefines its boundaries and size) and Reallocate-Reduce(Allocates a new smaller space in memory for an object at a new address, copies part of the object content there, reassigns the pointer, and deallocates the previous piece of memory)."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESMemory Addressing Bugs (MAD) - The pointer to an object is initialized, repositioned, or reassigned to animproper memory address.Memory Allocation Bugs (MAL) - An object is allocated, extended, or reallocated (while extending) improperly.Memory Use Bugs (MUS) - An object is initialized,read, written, or cleared improperly.Memory Deallocation Bugs (MDL) - An object is deallocated, reduced, or reallocated (while reducing) improperly.Each of these classes represents a phase, aligned with the Memory Bugs Model, and is comprised of sets of operations,cause/consequence relations, and attributes. "
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESA. OperationsAll BF classes are being designed to be orthogonal; theirsets of operations should not overlap. The operations in whichmemory bugs could happen are defined in Table I.The MAD operations are: Initialize (Pointer), Reassign,Reposition. They reflect improper formation of an address.The MAL operations are: Allocate, Extend, and Reallocate-Extend. They reflect improper formation of an object.The MUS operations are: Initialize (Object), Dereference,Read, Write, Clear. They reflect improper use of an object. The MDL operations are: Deallocate, Reduce, Reallocate-Reduce. They reflect improper release of an object.MAD Initialize and MUS Initialize are not overlapping, asthe former is about the address, the latter is about the object."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESB. CausesA cause is either an improper operation or an improperoperand. The values for improper memory operations are:Missing, Mismatched, and Erroneous. See definitions in Table II. The operands of a memory operation are pointer andobject. See definitions in Table III. All values for improperoperands of a memory operation are defined in Table IV.An improper pointer could be a reference. Commentscould be used to provide details, such as the pointer orreference identifier. An improper object could be a primitive data type or a data structure. Comments could be used toprovide details, such as the object data type and identifier.All possible causes for memory bugs are defined inTable II and Table IV. When describing a chain of bugs/weaknesses, the pointerand the object should be analyzed carefully, as they maybe different for each improper state. The description shouldreflect the changes and provide details in the comments."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESTABLE II: Improper OperationsAs being said before,a cause is either an improper operation or an improperoperand.First we should start from improper operartions which are divided by three values.So,memory bugs should be caused from values such asmissing(The operation is absent) and for example <<Missing object initialization>> . Another value of cause is mismatched(The deallocation function does not match the allocation function used for the same object) and for example <<Use of free() onan object allocated with new.>> . The last one value is erroneous(There is a bug is in the implementation of the operation.)  and for example <<Allocation with malloc() returns a non existing address>> ."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESC. ConsequencesA consequence is either an improper operand or afinal error. As a consequence, an improper pointer or animproper object would become a cause for a next weakness.These consequence-cause transitions explain why these twokinds of consequences have the same possible values as thecorresponding kinds of causes .The only kind of MAD consequences is ImproperPointer, which means a MAD bug or weakness is alwaysfollowed by another memory weakness, such as of MAL,MUS, or MDL. The only kind of MUS consequences isMemory Error, which means MUS always ends in a failure."
Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESTABLE III: Operands The operands of a memory operation are pointer(A holder of the memory address of an object) and object(A memory region used to store data).
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESTABLE IV: Improper OperandsThe operands are explained further above separated by pointer and object.(a) Improper PointerThe value NULL Pointer points to the zero address, a specific invalid address.The value Wild Pointer points to an arbitrary address, because it has not been initialized or an erroneous allocation routine is used.The value Dangling Pointer points to the address of its successfully deallocated object.The value Over Bounds points over the bounds of its object.The value Under Bounds points under the bounds of its object.The value Untrusted Pointer is the pointer is modified to an improperly checked address.The value Wrong Position points to a miscalculated position inside object bounds.The value Hardcoded Address points a wrong specific address.The value Casted Pointer is the pointer who does not match the type of the object, due to wrong type casting.The value Forbidden Address points to an OS protected or non-existing address.The value Single Owner of Object is the only pointer of an already allocated object is used to allocate a new object."
Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESTABLE IV: Improper OperandsThe operands are explained above separated by pointer and object b) Improper ObjectThe value Not Enough Allocated is the allocated memory is too little for the data it shouldstore.The Wrong size used is the value used as size does not match the real size ofthe object.
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESTABLE V: Memory ErrorsAll possible memory errors are defined above:The value of memory overflow is the definition for more memory requested than available, which causes a risk for Stack/heap exhaustion.The value of Memory Leak defined by An object has no pointer pointing to it, which causes a risk of Resource exhaustion,Application crash,DoS.The value of Double Free defined by the Attempt to deallocate a deallocated object or via an uninitialized pointer which causes a risk of Arbitrary code execution.The value of Object Corruption defined by Object data is unintentionally altered, which causes a risk of Wrong/unexpected results.The value of Uninitialized Object defined by Object data is not filled in before use,which causes a rick of Controlled or left over data.The value of Not Cleared Object defined by Object data not overwritten before deallocation,which causes a risk of Information exposure(e.g. private keys).The value of NULL Pointer Dereference defined by Attempt to access an object for read or write through a NULL pointer, which causes a risk of Program crash,Arbitrary code execution (in some OSs).The value Untrusted Pointer Dereference defined by Attempt to access an object via an altered pointer, which causes a risk of DoS, Arbitrary code execution.The value of Type Confusion defined by Type Confusion defined by Pointer and object have different types,which causes a risk of Vtable corruption and Hijack.The value of Use After Free defined by the attempt to use a deallocated object,which causes a risk of Arbitrary code execution.The value of Buffer Overflow defined by the Read or write above the object upper bound,which causes a risk of Arbitrary code execution and Information exposure.The value of Buffer Underflow defined by Read or write below the object lower bounds, which causes a risk of Arbitrary code execution and Information exposure.The value of Unitialized Pointer Derefereance defined by the attempt to access an object for read or write via an uninitialized pointer, which control flow hijack."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESD. AttributesAn attribute provides additional useful informationabout the operation or its operands. All Memory Bugs classes have the following attributes:Source Code, Execution Space, and Location.They explain where a bug is in three dimensions: where is the operation in the program, where its code is running, and where the object is stored in memory.All Memory Bugs classes have also the operation attribute Mechanism, but with different possible values."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESD. AttributesFor MAD and MUS Mechanism qualifies an operation as Direct or Sequential, depending on if an object element is accessed directly or after going through previous elements.For MAL and MDL Mechanism qualifies an operation as Implicit or Explicit. For MAL, Implicit means automaticcompile-time allocation. Improper results from implicit allocation are not enough memory allocated or too much memory requested, overflowing the stack (e.g., via a recursion). ForMDL, Implicit means automatic deallocation at the end ofscope. Bugs in automatic memory allocation or deallocationare rare (e.g., the gcc compiler bug [6]). For MAL, Explicitmeans dynamic run time allocation (e.g. using malloc()or new). For MDL, Explicit means dynamic run time deallocation (e.g. using free() or del)."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESD. AttributesMAL and MDL have also the pointer attribute Ownership. It shows how many pointers point to an object: None,Single, and Shared. See definitions of values in Table VIc. ForMAL, it shows how many pointers hold the allocated object.For MDL, if an object has no pointer pointing to it, it willbe unreachable for deallocation in an environment without agarbage collector. Multiple pointers to the same object couldlead to race conditions and dangling pointers.MUS has also the pointer attribute Span. It shows how many bytes are being used: Little, Moderate, Huge, dependingon if those are a few, more than a few and less than one KB or more than one KB."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESD. AttributesTABLE VI: Attributes(a) MAD, MAL, MUS, MDL AttributesAs said before, all Memory Bugs classes have the following attributes:Source Code, Execution Space, and Location.  The source includes the values of codebase(The operation is in programmer's code - in theapplication itself), Third Party(The operation is in a third party library), Standard library(The operation is in the standard library for a particular programming language) and the Language Processor(The operation is in the tool that allows execution or creates executable (compiler, assembler, interpreter). The execution space includes the values of Userland(The bugged code runs in an environment withprivilege levels but in unprivileged mode), Kernel ( The bugged code runs in an environment withprivilege levels with access privileged instructions) and Bare-Metal(The bugged code runs in an environment without privilege control. Usually, the program is the only software running and has total access to the hardware). The location includes the values of stack(The object is a non-static local variable) and heap(The object is a dynamically allocated data structure)."
Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESD. AttributesTABLE VI: Attributes(b) MAD and MUS AttributesFor MAD and MUS Mechanism qualifies an operation as Direct(The operation is performed over a particularobject element) or Sequential(The operation is performed after iterating overthe object elements).
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESD. AttributesTABLE VI: Attributes(c) MAL and MDL AttributesFor MAL and MDL Mechanism qualifies an operationas Implicit(The operation is performed without a functioncall) or Explicit(The operation is performed by a function/method call).The MAL and MDL have also the pointer attribute Ownership. It shows how many pointers point to an object: None(The object has no owner),Single(The object has one owner) and Shared(The object has more than one owner)."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESD. AttributesTABLE VI: Attributes(d) MUS AttributesMUS has also the pointer attribute Span.It shows how many bytes are being used: Little(A few bytes of memory are accessed), Moderate(Several bytes of memory are accessed, but lessthan 1 KB) and Huge( More than 1 KB of memory is accessed)."
"Classifying Memory Bugs Using Bugs Framework Approach- IV. BF MEMORY BUGS CLASSESE. SitesMAD sites are any changes to a pointer via assignment(=) or repositioning via an index ([]) or pointer arithmetics(e.g., p++ and p--).MAL sites are any allocation routine (e.g., malloc())or operator (e.g. new), declaration of a variable with implicit allocation, OOP constructor, or extension routine (e.g.,realoc()) or adding elements to a container object.MUS sites are any dereference operators in the sourcecode (*, [], ->, .).MDL sites are any deallocation routine (e.g., free())or operator (e.g. del), end of scope for implicit allocated variables, OOP destructor, or reduction routine (e.g.,realoc()) or removing elements from a container object."
"Classifying Memory Bugs Using Bugs Framework Approach- V. THE BF MEMORY CLASSES AS CWE EXTENSIONBF Memory Bugs taxonomy can be used by bug reporting tools, as it is a structured extension over memoryrelated CWEs. All Memory Error consequences from theBF classes (Table V) relate to one or more CWEs."
"Classifying Memory Bugs Using Bugs Framework Approach- V. THE BF MEMORY CLASSES AS CWE EXTENSIONWe have generated a digraph (Fig. 6) of all memoryrelated CWEs to show how they correspond to the possibleBF Memory Error consequences (Table V). An edge starts ata parent CWE and ends at a child CWE. The outline style ofa CWE node indicates the CWE level of abstraction: pillar,class, base, or variant. Bug reporting tools would use base orvariant CWEs, but they may also use higher abstraction levelCWEs if there is not enough specific information about thebug or if there is no related base CWE."
"Classifying Memory Bugs Using Bugs Framework Approach- V. THE BF MEMORY CLASSES AS CWE EXTENSIONThe digraph helped us identify clusters of memoryrelated CWEs. All these CWEs can be tracked as childrenof the pillar CWE-664, with the only exception of CWE-476(NULL Pointer Dereference). The largest cluster comprisesCWE-118 and the children of CWE-119, which are weaknesses associated with reading and writing outside the boundaries of an object. The second cluster comprises the childrenof CWE-400 and CWE-665, which are mainly weaknessesrelated to memory allocation and object initialization. Thechildren of CWE-404, which are weaknesses associated withimproper memory cleanup and release, form the third cluster.The smallest cluster comprises CWE-704, CWE-588 andCWE-843, which are memory use or deallocation weaknessesdue to the mismatch between pointer and object types."
"Classifying Memory Bugs Using Bugs Framework Approach- V. THE BF MEMORY CLASSES AS CWE EXTENSIONThe color of a CWE node indicates the BFmemory class associated with that CWE. A BF class isassociated with a CWE if the BF class has a Memory Errorconsequence covered by the CWE description. CWEs relatedto the BF MUS memory errors are presented in blue, CWEsrelated only to MAL are presented in pink, and CWEs relatedto both MAL and MDL are presented in green."
"Classifying Memory Bugs Using Bugs Framework Approach- V. THE BF MEMORY CLASSES AS CWE EXTENSIONMost of the BF MUS Memory Error consequences relate to CWEs from the CWE-118 cluster. TheMemory Error consequences from BF MAL and BF MDL relate to CWEs across clusters. Notethat the BF MAD class has no Memory Errorconsequences, so it does not directly relate to any CWE."
"Classifying Memory Bugs Using Bugs Framework Approach- V. THE BF MEMORY CLASSES AS CWE EXTENSIONThe BF Memory Bugs model reflects the lifecycle of an object. While the pillar CWE-664 reflects the""lifetime of creation, use, and release"" of a resource, it isquite broad. It is the parent of many CWEs that are not strictlymemory-related. We use asterisks (*) to denote CWEs that areabout any resource. CWE-704 is not a memory-related CWE,but is visualized on the digraph to show all the parent-childrelationships."
"Classifying Memory Bugs Using Bugs Framework Approach- V. THE BF MEMORY CLASSES AS CWE EXTENSIONThe identified clusters of memory CWEs do not strictlycorrespond to the phases of address formation, allocation,use, and deallocation. CWEs related to a phase appear inmore than one cluster. In addition, CWE-118 and CWE-119are strictly about memory but cover more than one phase.Viewed as a structured extension, the BF Memory Bugsclasses relate to CWEs through particular Memory Errorconsequences. For BF MAL: Memory Overflow - relates toCWEs: 400*, 770*, and 789; Memory Leak - to CWEs: 401,404*, 771*, and 772*; Double Free - to CWE-415;  ObjectCorruption - to CWEs: 404*, 590, 761, 762, and 763."
"Classifying Memory Bugs Using Bugs Framework Approach- V. THE BF MEMORY CLASSES AS CWE EXTENSIONFor BF MUS: Uninitialized Object - relates to CWEs:456, 457, 665*, 908*, and 909*; Not Cleared Object - toCWEs: 226*, 244, and 459*; NULL Pointer Dereference -to CWE-476; Untrusted Pointer Dereference - to CWEs: 119and 822; Type Confusion - to CWEs: 588 and 843*; UseAfter Free - to CWEs: 119, 416, and 825; Buffer Overflow- to CWEs: 118, 119, 120, 121, 122, 123, 125, 126, 466,805, 806, 787, and 788; Buffer Underflow - to CWEs: 118,119, 122, 123, 124, 125, 127, 466, 786, 787, 805, and 806;Unitialized Pointer Dereference - to CWEs: 119 and 824.There are no related CWEs to BF MUS Object Corruption."
"Classifying Memory Bugs Using Bugs Framework Approach- V. THE BF MEMORY CLASSES AS CWE EXTENSIONFor BF MDL: Memory Leak - relates to CWEs: 401,404*, and 771*; Double free - to CWE-415; Object Corruption - to CWEs: 404*, 761, 762, and 763."
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONIn this section, we use the new BF Memory Bugs classesfor precise descriptions of real world software vulnerabilities.We also provide the real world fixes of each bug."
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONA. CVE-2018-20991 - Rust SmallVec Iterator PanicThis vulnerability is listed in CVE-2018-20991. The source code could be found at. InRust, a panic is an unrecoverable error that terminates thethread, possibly unwinding its stack (calling destructors as ifevery function instantly returned)."
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONA. CVE-2018-20991 - Rust SmallVec Iterator Panica) Brief Description: Rust is a multi-paradigmprogramming language focused on safe concurrency. It hasa similar syntax to C++ and offers features to deal withdynamic memory allocation, such as smart pointers [11]. Ingeneral, a Rust programmer does not need to keep trackof memory allocation and deallocation, as the language isdesigned to be memory safe this way"
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONA. CVE-2018-20991 - Rust SmallVec Iterator Panicb) Analysis: The versions before Rust 0.6.3 havea bug in the lib.rs file. The insert_many() methodin the SmallVec class has two parameters: an iterableI and an index. The method inserts all elements in theiterable I at position index, shifting all the followingelements backwards. In the SmallVec class, if an iterator passed to SmallVec::insert_many() panics inIterator::next, the destructor is called while the vectoris in an inconsistent state, possibly causing double free(deallocation via references to same object). "
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONA. CVE-2018-20991 - Rust SmallVec Iterator Panicc) The Fix: To fix the bug, the Rust community opted to set the SmallVec length to index, callinsert_many(), and then update the length. With thisfix, if an iterator panics, a memory leak occurs [12]. Thedevelopers downgraded the bug to avoid double free as aconsequence, which could lead to arbitrary code execution.Now they have a memory leak."
Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONB. CVE-2014-0160 - Heartbleed Buffer OverflowThis vulnerability is listed in CVE-2014-0160 and discussed in [13]. The source code could be found at [14].
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONB. CVE-2014-0160 - Heartbleed Buffer Overflowa) Brief Description: Heartbleed is a vulnerabilitydue to a bug in the OpenSSL - a crypto library for theTransport Layer Security (TLS) and Secure Sockets Layer(SSL) protocols. Using the heartbeat extension tests in TLSand Datagram Transport Layer Security (DTLS) protocols,a user can send a heartbeat request to a server. The requestcontains a string and a payload unsigned integer, whichvalue is expected to be the string size. The server respondswith the same string. However, due to the bug, a malicioususer could set the payload as big as 65535 and the serverwould read out of bounds. This could expose confidentialinformation that was not cleared before release"
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONB. CVE-2014-0160 - Heartbleed Buffer Overflowb) Analysis: The TLS and DTLS implementations in OpenSSL 1.0.1 before 1.0.1g have a bug inthe d1_both.c and t1_lib.c files. In the Heartbleedattack, the software stores the user data in an arrays?>s3?>rrec.data[0]. The size of that array is muchless than the huge 65535 bytes payload. The software doesnot check the size of the data (s?>s3?>rrec.length)towards the value of the payload. It assumes these numbersare equal and using memcpy() reads payload consecutivebytes from the array, beginning at its first byte, then sendsthem to the malicious user."
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONB. CVE-2014-0160 - Heartbleed Buffer Overflowc) The Fix: To fix the bug the openSSL team addeda bound check for the array size [15]. We should note thatin Fig. 9 the Wrong Size Used cause is a consequence froma missing Verify operation of a preceding Data VerificationBug (DVR) [1], which is beyond the scope of this paper."
Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONC. DiscussionThe BF taxonomy of a vulnerability can help identifyexploit mitigation techniques for a particular weakness types.For that we should connect the BF taxonomy to an appropriate attack model.
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONC. DiscussionFor memory bugs, we can use the classic memorycorruption attack model of Szekeres et al. [16] that systematizes the memory protection techniques. The model has sixsteps towards the ultimate goal of an attacker. Its very firstlevel is on memory safety, where an attacker can start anexploitation with an invalid pointer dereference. This kind ofinvalid pointer corresponds to the improper pointer states thatdefine some of the causes for the BF Memory Bugs classes."
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONC. DiscussionUsing the BF description of a vulnerability and following the attack model we can identify effective mitigationsagainst possible attacks. Let's take, for example, a BufferOverflow that is caused by Read Over Bounds. Following theSzekeres et al. model, such a bug would allow an attacker toaccess program data, leading to information leakage."
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONC. DiscussionTo make use of the collected data, the attacker shouldbe able to interpret it. Probabilistic methods such as dataspace randomization (DSR) could mitigate the attack, whilean address space location randomization (ASLR) will notdo it [17]. The values of the Location and Execution Spaceattributes of the object help identify where in the memorylayout the mitigation technique should be put in place."
"Classifying Memory Bugs Using Bugs Framework Approach- VI. SHOWCASES AND DISCUSSIONC. DiscussionThe Szekeres et al. model, however does not cover bugsrelated to some BF memory operations, such as allocation,reallocation, and initialization. It does not cover any memoryaddressing bugs (MAD) and it is not concerned describinghow a pointer becomes invalid. A key point here is thatSzekeres et al. look at memory corruption bugs from attacksperspective, while we focus on systematizing information thatis sufficient to fix a bug."
"Classifying Memory Bugs Using Bugs Framework Approach- VII. CONCLUSIONIn this paper, we introduce four new BF classes: MemoryAddressing Bugs (MAD), Memory Allocation Bugs (MAL),Memory Use Bugs (MUS), and Memory Deallocation Bugs(MDL). We present their operations, along with the possiblecauses, consequences, attributes, and sites."
"Classifying Memory Bugs Using Bugs Framework Approach- VII. CONCLUSIONWe analyze particular vulnerabilities related to theseclasses and provide precise BF descriptions. The BF structured taxonomies of memory corruption vulnerabilities showthe initial error (the bug) providing a quite concise and stillfar more clear description than the unstructured explanationsin current repositories, advisories, and publications."
"Classifying Memory Bugs Using Bugs Framework Approach- VII. CONCLUSIONLinking the BF Memory Bugs model and taxonomy toan attack model (e.g. Szekeres et al. model) would providethe means of covering the memory corruption vulnerabilitieslandscape. For example, the first layer of the Szekeres modelcould connect with the BF causes defined in Section IV-B.As part of that, the notion of invalid pointer should not berestricted to dangling pointers and out of bounds pointers;refinement to the causes in Table IVa should be considered.The BF Memory Bugs taxonomy can be used by bugreporting tools, as it can be viewed as a structured extensionover the memory related CWEs. Furthermore, the BF descriptions of particular vulnerabilities can be used to identify exploit mitigation techniques."
"Critical Software Security Weaknesses- AbstractIn this work, we extend our historical study on the most significant software security weaknesses, re-evaluate our findings, and look closely at the Injection and Memory Corruption/Disclosure weaknesses through the NIST Bugs Framework (BF) lenses. Our goal is to continue raising awareness about the patterns of reoccurring software security vulnerabilities that enable malicious activity."
"Critical Software Security WeaknessesRaising awareness about the most critical software security weaknesses would urge programmers, software developers, and security experts concentrate their efforts on preventing them. Ultimately, this would reduce the number and severity of new vulnerabilities discovered over time."
"Critical Software Security WeaknessesA software security vulnerability, as defined by the National Institute of Standards and Technology (NIST)Bugs Framework (BF), is ""a chain of weaknesses linked by causality starts with a bug and ends with a final error, which, if exploited leads to a security failure""."
"Critical Software Security WeaknessesIn the year 2022, there were a staggering number of 25,000(and more) software vulnerabilities documented in the Common Vulnerabilities and Exposures (CVE) repository. Although a huge number of these vulnerabilities has been detected, they can be traced back to a considerably small set of underlying weaknesses."
"Critical Software Security WeaknessesA significant weakness, is one that is both commonly found among publicly documented vulnerabilities and leads to severe security issues (such are those that are easily exploitable and have a high impact)."
"Critical Software Security WeaknessesIn this article, we take a fresh look at the most significant software security weaknesses. We applyour Most Significant Security Weaknesses (MSSW) equation, which is designed to as evenly as possiblefactor together frequency and severity. We complement our historical study with new data from the last threeyears, 2021-2023. Then we re-evaluate our previous research(paper named as A decade of reoccurring software weaknesses) and confirm that injection and memory corruption/disclosure continue to reappear as the most dangerous software security weaknesses. We also look closely at injection and memory corruption/disclosure through the lens of the NIST Bugs Framework (BF) to continue raising awareness about the patterns of reoccurring software security vulnerabilities that enable malicious activity."
Critical Software Security Weaknesses- Identifying Critical WeaknessesWe identify significant weaknesses by applying our previously developed Most Significant Security Weaknesses (MSSW) equation to the Common Weaknesses Enumeration (CWE) View-1003 entries considering the CWE model levels of abstraction.
"Critical Software Security Weaknesses- Identifying Critical WeaknessesThe CWE is an enumeration of 933 types of software weaknesses with descriptions and references. Each CWE entry is assigned a CWE-X ID, where X is an integer [8]. CWE View-1003 [9] is a subset of 130 CWEs selected specifically for the NIST National Vulnerabilities Database (NVD) [10] effort of labeling CVEs with CWEs. The CWE model comprises four layers of abstraction: Pillar, Class, Base, and Variant; and can use a Compound to associate two or more interacting or co-occurring CWEs. The abstractions reflect five dimensions: behavior, property, technology, language, and resource. Variant CWEs are the most specific; they describe at least three dimensions. Base CWEs are more abstract than variants and more specific than classes; they describe two to three dimensions. Class CWEs are very abstract; they describe one to two dimensions, typically not specific about any language or technology. Pillar CWEs are the highest level of abstraction."
Critical Software Security Weaknesses- Identifying Critical WeaknessesWe assess the CWE frequency and severity using the MSSW equation on NVD as a data source. TheNVD assigns for each CVE a Common Vulnerability Scoring System (CVSS) score and a relevantCWE from View-1003 as the weakness allowing the vulnerability. The CVSS score provides a numerical assessment of the severity of a vulnerability by capturing its primary characteristics. 
"Critical Software Security Weaknesses- Identifying Critical WeaknessesFor each year, we identify the 10 CWEs with the highest MSSW value and rank them in descending order. Then, we plot the top 10 CWEs for each year to visualize and analyze how the most dangerous software security weaknesses have evolved through a period of years."
"Critical Software Security Weaknesses- Historical AnalysisWe complement our previous historical analysis over the CWEs from View-1003 for the 2010-2020 period with new data for the last three years, 2021-2023."
"Critical Software Security Weaknesses- Historical AnalysisThe MSSW Top 10 Base/Variant/Compound (BVC) CWEs for the last 12.5 years shows the Top 10 list of CWEs for each year for the Base, Variant, and Compound (BVC) layer. The Top 10 Pillar/Class (PC) CWEs for the last 12.5 years shows the same for the Pillar and Class (PC) layer. Each oval with a number represents a CWE with its ID. The darkness of an oval indicates the number of times that particular CWE is used in a CVE over the years. Darker ovals correspond to the most frequent CWEs and lighter ovals correspond to the less frequent CWEs in the Top 10 lists."
"Critical Software Security Weaknesses- Historical AnalysisCompared to the preceding decade, the software security weaknesses landscape has not evolved in thelast three years. Both MSSW Top 10 Base/Variant/Compound (BVC) CWEs and Top 10 Pillar/Class (PC) CWEs are rather dark at the 2021-2023 columns, indicating that the Top 10 weaknesses found in the last three years are very frequent. Moreover, these are the same weaknesses that are seen in the previous years and that keep reoccurring. For the BVC layer, all the CWEs seen in the Top 10 weaknesses, except for one (CWE-306), in the last three years were already present in the top 10 CWEs of the preceding decade. Among the 88 possible BVC CWEs, only 20 are present in the last 12.5 years. Similarly, for the PC layer, only CWE-706 was not present in the Top 10 lists of the preceding 10 years. Additionally, for the PC layer, the Top 4 lists have been unchanged in the last three years; and among the 39 possible PC CWEs, only 18 appear in the last 12.5 years."
"Critical Software Security Weaknesses- Historical AnalysisThese results show that a minority subset of CWEs have dominated the Top 10 lists for the last three yearsand the decade preceding them; from this vantage point the software weaknesses landscape is practicallynot changing. Instead of seeing a diversity of CWEs entering the Top 10 lists, the same kinds of weaknesses reappear year after year."
"Critical Software Security Weaknesses- Historical AnalysisThe two groups of weaknesses dominating the Top 10 lists are injection and memory corruption/disclosure. This is illustrated by the sum of the MSSW score of all CWEs in the BVC Top 10 list of each year, which shows how the MSSW score in our BVC Top 10 lists evolves over the years. The blue line presents the sum of the MSSW score of all CWEs in the BVC Top 10 list of each year. The red line shows the sum for injection CWEs, while the green line shows the sum for memory corruption/disclosure CWEs. The yellow line shows all 'other CWEs', which are neither injection nor memory corruption/disclosure; these include CWEs related to file management, integer arithmetic, authentication, authorization, cryptographic authentication, and cryptographic verification."
"Critical Software Security Weaknesses- Historical AnalysisOne can observe in the sum of the MSSW score of all CWEs in the BVC Top 10 list of each year a consistent increase in the sum of the MSSW scores of all Top 10 BVC CWEs during the last 12.5 years. This represents a shift towards a subset of CWEs that increasingly become both the most frequent and the most impactful. Note that this is not due simply to an increase in the number of vulnerabilities discovered, because both frequency and impact are normalized within MSSW. One explanation for this trend could be that attackers are increasingly leveraging CWEs that give them the greatest influence on the targeted software systems."
"Critical Software Security Weaknesses- Historical AnalysisInjection and memory corruption/disclosure CWEs dominate the Top 10 lists and follow this trend ofincreasing MSSW scores. Analyzing the MSSW Top 10 Base/Variant/Compound (BVC) CWEs for the last 12.5 years, we can conclude that after 2017, all the five most dangerous CWEs are consistently either injection or memory corruption/disclosure. After 2019, only two CWEs are outside of those groups in the BVC Top 10 lists. This explains the increase of the MSSW score sum for injection and memory corruption/disclosure CWEs and the decrease of the MSSW score sum for other CWEs."
"Critical Software Security Weaknesses- Injection:The Most Dangerous Software Security WeaknessThe NIST Bugs Framework (BF) defines injection as ""an undefined or exploitable system behavior causedby code separation data validation bugs"". Injection occurs because of violation of the data separationprinciple in modern application models. Data and code have the same internal representation and there is noformal way to distinguish them at that level. However, looking through the lens of BF, we can clearly seethat code is an operation that the program executes - a behavior; and data are the operands used bythe operation to produce an output. This allows us to distinguish them and reason about them on a higherlevel. When code (operations) and data (operands) are mixed, unexpected behaviors may arise from unpredictable data values. Therefore, programmers must be aware of the values of the input data to operations to ensure the application behaves appropriately."
"Critical Software Security Weaknesses- Injection:The Most Dangerous Software Security WeaknessWe identify the most dangerous injection weaknesses (see The MSSW Top 10 Base/Variant/Compound (BVC) CWEs for the last 12.5 years, CWEs with red IDs) applying the MSSW equation. From 2018 to 2023, injection is represented by CWE-89 (SQL Injection), CWE-78 (OS Command Injection), CWE-502 (Deserialization of Untrusted Data), CWE-94 (Code Injection), and CWE917 (Expression Language Injection)."
"Critical Software Security Weaknesses- Injection:The Most Dangerous Software Security WeaknessThe BF taxonomy groups injections into five exploitable errors: Query Injection (for example CWE-89), Command Injection (for example CWE-78), Source Code Injection (for example CWE-94, CWE-502, and CWE-917), Parameter Injection, and File Injection. They all are caused by improper input data validation or sanitization and allow malicious insertions: ""Query Injection allows malicious insertions of condition parts or entire commands into an input used to construct a database query""; ""Command Injection - of new commands into the input to a command that is sent to an operating system (OS) or a server""; ""Source Code Injection - of new code into input used as part of an executing application code""; ""Parameter Injection - of data into input used as parameter/argument in other parts of code""; and ""File Injection - of data into input used to access/modify files or as file content"". "
"Critical Software Security Weaknesses- Injection:The Most Dangerous Software Security WeaknessThe full 12.5 years plot shows that 'SQL Injection' is consistently the number one weakness in everyTop 10 BVC list, followed by 'OS Command Injection'. For the last three years, some interesting observations are that 'Code Injection' first went down, but then started climbing up again; and 'Source Code Injection' (CWE-94 and CWE-502) is consistently climbing up, although the rare CWE-917 has dropped off."
"Critical Software Security Weaknesses- Injection:The Most Dangerous Software Security WeaknessSQL Injection is by far the most dangerous weakness, according to our analysis. OS Command Injection is the second most dangerous injection weakness. It is also a contributor to Class CWE-77 (Improper Neutralization of Special Elements used in a Command ('Command Injection')) (see Figure 2). Code Injection, CWE-94, also plays a significant role in the top 10 lists and is a contributor to Class CWE-913 (Improper Control of Dynamically-Managed Code Resources)."
"Critical Software Security Weaknesses- Injection:The Most Dangerous Software Security WeaknessDeserialization of untrusted data (CWE-502) is a considerably new injection weakness. It appears forthe first time in the 2016 BVC Top 10 list. The reason being, the exploitation of deserialization bugs increased after November 2015, when Foxglove Security published their exploits for the Java deserializationweakness. From there on, currently CWE-502 is the second most dangerous injection weakness."
"Critical Software Security Weaknesses- Injection:The Most Dangerous Software Security WeaknessLooking through the lens of BF we can observe that three of the BF injection errors are solidly covered bythe top 10 lists in this analysis: CWE-89 corresponds to Query Injection; CWE78- to Command Injection; CWE-502, CWE-94, and CWE917 - to Source Code Injection."
"Critical Software Security Weaknesses- Injection:The Most Dangerous Software Security WeaknessThe causes for such exploitable errors identified by BF can be missing or erroneous code in a validateor sanitize operation, an under/over-restrictive policy, corrupted/tampered data, or corrupted/tampered policy data. If programmers learn to always properly check any input data, they should be able to avoid injection errors. The BF Data Validation (DVL) class is a good start to learn about bugs, faults, operations, errors and final (exploitable) errors related to injection."
"Critical Software Security Weaknesses- Memory Corruption/Disclosure: The Second Most Dangerous Software Security WeaknessesThe NIST Bugs Framework (BF) defines memory corruption/ disclosure as ""an undefined or exploitable system behavior caused by memory addressing, allocation/ deallocation, or use bugs"". Memory orruption/disclosure happens when data stored in memory are unintentionally modified or revealed via writing into or reading from an improper object, respectively. NULL pointer dereferencing is also related to both of them. An object is improper if its address (e.g., the associated pointer is over bounds) or size (for example not enough memory is available to allocate an object of that size) is improper; or if the data for its address (for example hardcoded address) or the data for its used size (for example not matching the actual size of the object) are improper; or if its type (its pointer/index type) is improper (for example casted pointer). Therefore, programmers must be aware of the values and the types of the pointers associated with the used object addresses and the values of the used sizes, to ensure the application behaves appropriately."
"Critical Software Security Weaknesses- Memory Corruption/Disclosure: The Second Most Dangerous SoftwareSecurity WeaknessesWe identify the most dangerous injection weaknesses (see the MSSW Top 10 Base/Variant/Compound (BVC) CWEs for the last 12.5 years, CWEs with red IDs) applying the MSSW equation. From 2018 to 2023, injection is represented by CWE-89 (SQL Injection), CWE-78 (OS Command Injection), CWE-502 (Deserialization of Untrusted Data), CWE-94 (Code Injection), and CWE917 (Expression Language Injection)."
"Critical Software Security Weaknesses- Memory Corruption/Disclosure: The Second Most Dangerous SoftwareSecurity WeaknessesThe BF taxonomy groups memory corruption/disclosure errors into 11 exploitable errors. To discussThe MSSW Top 10 Base/Variant/Compound (BVC) CWEs for the last 12.5 years, we focus here on the four exploitable errors associated with the most dangerous CWEs. BF defines them as follows: ""Buffer Overflow is writes above the upper bound of an object"". ""Buffer Underflow is writes below the lower bound of an object"". Use After Free is an attempt to read/write a deallocated object"". ""NULL Pointer Dereference is an attempt to access an object for reading or writing via a NULL pointer."" "
"Critical Software Security Weaknesses- Memory Corruption/Disclosure: The Second Most Dangerous SoftwareSecurity WeaknessesThe full 12.5 yeas plot shows that 'Out-of-bounds Write' appears in every Top 10 BVC list, while 'ClassicBuffer Overflow' appears in 2013 and 2019 and after. 'Use After Free' is present in the 2016top 10 and after, except for 2020."
"Critical Software Security Weaknesses- Memory Corruption/Disclosure: The Second Most Dangerous SoftwareSecurity WeaknessesClass CWE-119, which encompasses the general memory corruption/disclosure weakness 'Use AfterFree', is also an area of concern. All memory CWEs on the Top 10 lists contribute to this class, exceptfor CWE-476, which contributes to Class CWE-672. Given the broad scope of Class CWE-672, it is alsothe parent class of CWE-613. Addressing these memory corruption/disclosure weaknesses should be a toppriority to improve memory safety."
"Critical Software Security Weaknesses- Memory Corruption/Disclosure: The Second Most Dangerous SoftwareSecurity WeaknessesLooking through the lens of BF, we can observe that these four BF memory corruption/disclosure errorsare solidly covered by the top 10 lists in this analysis. CWE-787 and CWE-120 correspond to Buffer Overflow; CWE-787 - to Buffer Underflow; CWE-416 - to Use After Free; CWE-476 - to NULL Pointer Dereference."
"Critical Software Security Weaknesses- Memory Corruption/Disclosure: The Second Most Dangerous SoftwareSecurity WeaknessesThe causes for such exploitable errors can be missing or erroneous code in a read, a write, or adereference operation; or there is an improper address, size, address data, size data, or pointer type. Dataare improper if a hardcoded (wrong specific) or forbidden (OS protected or non-existing) address or awrong (not matching the actual object) size is used. Type is improper if a casted pointer is used. Addressis improper if the associated pointer is over/under bounds (of its object), wild (arbitrary - e.g., uninitialized), untrusted (improperly checked), or dangling (of a deallocated object). Size is improper if not enough memory is available. It is improper also to use a NULL (zero address) pointer when dereferencing an object. Therefore, programmers must be aware to properly maintain pointers and types and to check size and available memory to ensure the application behaves appropriately. If programmers learn to always properly define and use pointers and objects they should be able to minimize memory corruption/disclosure errors. The BF Memory Use (MUS) and Memory Management (MMN) classes are a good start to learn about bugs,faults, operations, errors, and final (exploitable) errors related to memory corruption/disclosure."
"Critical Software Security Weaknesses- Memory Corruption/Disclosure: The Second Most Dangerous SoftwareSecurity WeaknessesIt is worth noting that we have no choice but to deal with memory corruption/disclosure bugs in C legacyor embedded systems. However, we urge software developers to use programming languages (for example Rust)that provide memory safe alternatives such as smart pointers and other language features that prevent common memory safety issues."
"Critical Software Security Weaknesses- CONCLUSIONThe NIST National Vulnerabilities Database (NVD) uses the carefully selected 130 CWEs from VIEW1003 to label CVEs with CWEs. From those 130 weakness types, only a limited number of CWEs (20) appears in our BVC analysis over a time span of almost 12.5 years. Looking at the 2018-2023 period, we can see the picture is getting worse, while just a few CWEs change from year to year (there are only 14 different CWEs for that period). This indicates that year after year, security researchers keep finding similar vulnerability patterns in software. In other words, no new dangerous types of weaknesses are entering the Top 10 lists, except for the newly appeared in 2015 deserialization of untrusted data."
"Critical Software Security Weaknesses- CONCLUSIONWe are not a lone voice in the wilderness calling attention to this issue. The danger of software security weaknesses is widely publicized by successful projects, such as Open Worldwide Application SecurityProject (OWASP) Top 10 and MITRE Top 25. Still, these weaknesses keep reappearing in softwaresecurity vulnerabilities. As Information Technology (IT) professionals, we should make an extra effort to spread the word for prioritizing education in secure coding. Mitigation techniques are important, but programmers, software developers, and security experts should concentrate their efforts on preventing the possible causes for software security weaknesses. Let's start with the most dangerous ones - injection and memory corruption/disclosure - and ultimately, reduce the number and severity of new vulnerabilities discovered over time. We look forward to writing this very same paper, finding that, as a community, we are making progress in changing the software security vulnerability landscape for good."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight-AbstractIn this work, we present an orthogonal classification of data type bugs, allowing precise structured descriptions of related software vulnerabilities. We utilize the Bugs Framework (BF) approach to define four language-independent classes that cover all possible kinds of data type bugs. In BF each classis a taxonomic category of a weakness type defined by sets ofoperations, cause/consequence relations, and attributes. A BFdescription of a bug or a weakness is an instance of a taxonomicBF class with one operation, one cause, one consequence, andtheir attributes. Any vulnerability then can be described as achain of such instances and their consequence-cause transitions.With our newly developed classes Declaration Bugs, NameResolution Bugs, Type Conversion Bugs, and Type ComputationBugs, we confirm that BF is a classification system that extendsthe Common Weakness Enumeration (CWE). The proposedclasses allow clear communication about software bugs thatrelate to misuse of data types, and provide a structured wayto precisely describe data type related vulnerabilities."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight-INTRODUCTIONData types and the operations they define are an abstraction for real-world modeling problems. The purpose of data types is to mitigate bugs, which is achieved by compilers andinterpreters enforcing specific data type rules."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight-INTRODUCTIONUnfortunately, misunderstanding data type peculiaritiescould create severe software weaknesses and lead to vulnerabilities, such as the recently discovered Type Confusion vulnerability on Chromium. This work aims to classify alldata type bugs and to define the kinds of related errors thatwould allow us to precisely communicate and teach aboutthem, as well as to identify them in code and avoid relatedsecurity failures."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight-INTRODUCTIONSecure software development is critical for securingcyberspace and critical infrastructure. However, writing secure code is hard, time consuming, and thus often omitted. Many software bugs/weaknesses get introduced by unawaredevelopers and possibly left undetected by testers and codereview tools. As a result, software security vulnerabilities arestill a huge part of the attack surface used by threat agents."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight-INTRODUCTIONCommon Vulnerabilities and Exposures (CVE) entries toCommon Weaknesses Enumeration (CWE) entries. TheCISA Known Exploited Vulnerabilities Catalog (KEV) is also based on the CVE. It identifies publicly exploited vulnerabilities with top priority for remediation. However,CVE has proven to be difficult to use in research, as manyCWEs and CVEs have imprecise descriptions with unclearcausality and lack explainability. Being an enumeration,the CWE also has gaps and overlaps in coverage."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight-INTRODUCTIONThe Bugs Framework (BF) aims to address all these CWE and CVE problems and to further benefit NVD and KEV, as well as to facilitate code review tools and vulnerability research. It is being developed as a structured, complete, orthogonal, and language-independent classification systemof software bugs and weaknesses. Structured means a weakness is described via one cause, one operation, one consequence, and one value per attribute from the appropriate lists defining a BF class. This ensures precise causal descriptions. Complete means BF has the expressiveness power to describe any software bug or weakness. This ensures there are no gaps in coverage. Orthogonal means the sets of operations of any two BF classes do not overlap. This ensures there are no overlaps in coverage. BF is also applicable for source code in any programming language. The cause/consequence relation is a key aspect of BF's methodology that sets itapart from any other bugs/weaknesses classification effort. Itallows describing and chaining the bug and the weaknessesunderlining a vulnerability, as well as identifying a bug bygoing backwards from a final error or a failure, and what isrequired to fix that bug."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight-INTRODUCTIONWe utilize the BF approach to define four language-independent, orthogonal classes that cover all possible kinds of data type bugs and weaknesses: Declaration Bugs (DCL),Name Resolution Bugs (NRS), Type Conversion Bugs (TCV),and Type Computation Bugs (TCM). The BF Data TypeBugs taxonomy can be viewed as a structured extension tothe conversion, calculation (incl. comparison), wrap-around(incl. integer overflow), pointer scaling, coercion (juggling),and other data type related CWEs, allowing bug reportingtools to produce more detailed, precise, and unambiguousdescriptions of identified data type bugs."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight-INTRODUCTIONThe main contributions of this work are: i) we create amodel of data type bugs; ii) we create a taxonomy that hasthe expressiveness power to clearly describe any data typebug or weakness; iii) we confirm our taxonomy covers alldata type related CWEs; iv) we showcase the use of our datatype bugs taxonomy."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight-INTRODUCTIONWe achieve these contributions respectively via: i) identifying the operations, where run-time errors may happen despite the compiler or interpreter checks; ii) developingfour new structured, orthogonal BF classes: DCL, NRS, TCV, and TCM; iii) generating digraphs of CWEs related to data type weaknesses, as well as to data type consequencesand mapping these CWEs to BF DCL, NRS, TCV, and TCM by operation and by consequence; iv) describing realworld vulnerabilities using BF DCL, NRS, TCV, and TCM: CVE-2021-21834 and the Bad Allocation Chain, CWE-468, Example 1 - Incorrect Pointer Scaling, and CVE-2021-23440and Type Mismatch bypassing Input Validation."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight-INTRODUCTIONThe rest of the paper is organized as follows: InSection II, we recall BF's approach and methodology. InSection III, we discuss the role of type systems. In Section IV,we define the BF Data Type Bugs model. In Section V, wepresent our new BF DCL, BF NRS, BF TCV, and BF TCMclasses. In Section VI, we analyze the correspondence ofthe conversion, calculation (incl. comparison), and other datatype related CWEs to the new BF classes. In Section VII,we use the BF Data Type Bugs taxonomy to provide better,structured descriptions of two real-world vulnerabilities (CVEentries) and an example from a CWE entry. Finally,in Section VIII, we discuss related works and in Section IXwe summarize our contributions and propose future works."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- II.BF APPROACH AND METHODOLOGYThe Bugs Framework (BF) is being developed with thegoals of: (1) Classifying software bugs and weaknesses toallow precise descriptions of vulnerabilities that exploit them.(2) Identifying secure coding principles, such as type safety,memory safety, and input/output safety."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- II.BF APPROACH AND METHODOLOGYIn this paper, we use the terms software bug, weakness, and vulnerability as they are defined by Bojanovaand Galhardo in the paper named ""The Bugs Framework"". We utilize the latest BF approach andmethodology, as described in the paper named , ""Input/output check bugs taxonomy: Injection errors in spotlight"" and present here updates on the main ideas."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- II.BF APPROACH AND METHODOLOGYBF describes a bug or a weakness as an improper stateand its transition. The transition is to another weaknessor to a failure. An improper state is defined by the tuple(operation, operand1, ... , operandn), where at least oneelement is improper. The initial state is always caused by abug(a coding error within the operation), which, if fixed,will resolve the vulnerability. An intermediate state is causedby ill-formed data; it has at least one improper operand. Thefinal state, the failure, is caused by a final error (undefined orexploitable system behavior) that usually relates to a CWE.A transition is the result of the operation over the operands."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- II.BF APPROACH AND METHODOLOGYBF describes a vulnerability as a chain of improperstates and their transitions. Each improper state is an instanceof a BF class. The transition from the initial state is byimproper operation over proper operands. The transitionsfrom intermediate states are by proper operations with at leastone improper operand."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- II.BF APPROACH AND METHODOLOGYOperation or operand improperness defines the causes.A consequence is the result of an operation over its operands.It either becomes the cause for a next weakness or is a finalerror."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- II.BF APPROACH AND METHODOLOGYA BF class is a taxonomic category of a weakness type,defined by a set of operations, all valid cause/consequencerelations, and a set of attributes. The taxonomy of a particularbug or weakness is based on one BF class. Its description is an instance of a taxonomic BF class with one cause, one operation, one consequence, and their attributes. Theoperation binds the cause/consequence relation - e.g., alarge value of an argument to an addition arithmetic operatorleads to integer overflow."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- II.BF APPROACH AND METHODOLOGYCWEs coverage by newly developed BF classes can bevisualized via digraphs, based on CWEs parent-child relationships. Once analyzed, these digraphs can help understand the CWE structure and how the CWE entries translate to BF."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- II.BF APPROACH AND METHODOLOGYThe taxonomies of newly developed BF classes can bedemonstrated by providing structured BF descriptions of datatype related CVEs."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- II.BF APPROACH AND METHODOLOGYThe methodology for developing a BF class comprisesidentifying/defining: (1) the phase specific for a kind of bugs;(2) the operations for that phase; (3) the BF Bugs modelwith operations flow; (4) all causes; (5) all consequences thatpropagate as a cause to a next weakness; (6) all consequencesthat are final errors; (7) attributes useful to describe sucha bug/weakness; (8) the possible sites in code; (9) CWEdigraphs by class and consequence; (10) CVE showcases."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- II.BF APPROACH AND METHODOLOGYBF is a taxonomy for clearly describing bugs andweaknesses that leverages secure coding education and training. Secure coding is a software development technique introducing awareness of well-known weaknesses to avoidvulnerabilities. This paper introduces the BF Data Type Bugsclasses, which cover bugs related to type safety. Previousworks focused on memory safety and input/output safety, both critical steps of secure coding development."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- III.TYPE SYSTEMSType safety of programs is ensured by programminglanguages' Type Systems. A Type System checks explicit typing rules and applies built-in implicit typing rules to eliminate run-time errors. Explicit typing rules are onname resolution or any predetermined behavior, (e.g. allowingmultiplication only for numeric data types). Implicit typingrules are such as on type inference, argument coercion, orpolymorphic call resolution."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- III.TYPE SYSTEMSEach data type bug or weakness involves one datatype related operation. Each of these operations is over anentity: object, function, data type, or namespace. An entity isreferred in source code via its declared name. Names may beorganized in namespaces (or modules, or packages) to avoidname collisions. This eliminates ambiguity, allowing the samename to be declared in different scopes. A scope is a blockof code (e.g. { }) where a name is valid, i.e., associated withexactly one entity. Scopes provide the Type System with acontext for names lookup, i.e., what namespaces and in whichorder should be referred to resolve the name."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- III.TYPE SYSTEMSA data type defines a set or a range of values (e.g. charis within [-128, 127]) and the operations allowed overthem (e.g. +, *, mod). A data type can be primitive (e.g.int, float, double, string, boolean) or structured (e.g. array,record, union, class, interface). Primitive data types mimicthe hardware units; they are only language defined. Structureddata types are built from other data types; they have primitiveor structured members. The Type System checks if data typeshave been declared and used properly."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- III.TYPE SYSTEMSAn object is defined by Bojanova and Galhardo in ""Classifying Memory Bugs UsingBugs Framework Approach,"" as ""a piece of memory with well-defined size"", which ""addressshould be held by at least one pointer or determined as an offset on the stack"". This piece of memory is used to store the value of a primitive data or a data structure. An objectis declared via a name and a data type. It may be a memberof a data structure (e.g. an attribute of a class). An objectis referred in source code via its name. If a data type is notspecified, the Type System may infer it from the object's datavalue. An object is defined by the data it stores."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- III.TYPE SYSTEMSA function is an organized block of code that whencalled takes in data, processes it, and produces a result(s).Functions also get stored in memory. A function is declaredvia a return data type, a name, and a list of parameters. Itmay be a member of a data structure (e.g. a method of aclass). If a return data type is not specified, the Type Systemmay infer it from the returned data value. A function maybe anonymous, t.e. it may have no name - e.g. a lambdaexpression. A function is defined by its block of code - thefunction implementation. A function is referred in sourcecode via its name and called via its signature (name andarguments - number, order, and data types matter). A functioncall may be an argument to another function - e.g. to anoperator in an arithmetic expression."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- III.TYPE SYSTEMSThe declaration of an entity may be prefixed by amodifier that enforces required restrictions. For example,access modifiers restrict whether and how a data type, anobject, or a function can be used outside its declaration scope."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- III.TYPE SYSTEMSObject Oriented Programming (OOP) languages extendto Polymorphic Type Systems, allowing use (a) of same codefor different data structures or (b) of different code via samefunction name. They introduce the notions of type parameters,subtyping (via inheritance), dynamic typing and overriding, and the concept of overloading."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- III.TYPE SYSTEMSType Parameters allow encoding of a generic data type,parameterized by the data types of its member objects andits member functions. A generic member function essentiallyworks the same way on different types of data structures. Anexample of parametric polymorphism (generics) would be ageneric sort function that works the same way over a list ofintegers as over a list of strings."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- III.TYPE SYSTEMSSubtyping is the ability to define new data types basedon previously defined data types. Via such inheritance, twostructurally different data types may share members. DynamicTyping is the ability for objects to change their data types atrun time - e.g. the data type of a base class object may be anyof its class subclasses. An example of subtype polymorphism(overriding) would be a dynamically typed element of anarray of Shape objects invoking the proper draw() methoddepending on the element's actual subtype."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- III.TYPE SYSTEMSBoth overriding and overloading are about the abilityto use the same function name for different implementations:overriding is across subtypes in the same hierarchy; overloading is in the same declaration scope. An example of compiletime polymorphism (overloading) would be using the properinteger or double addition operator (int +(int x, inty); or double +(double x, double y);) depending onthe call arguments data types."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- III.TYPE SYSTEMSThe Type System resolves the declaration scopes of thereferred entity names; then binds the appropriate declared (orinferred) data types and the defined objects data and calledfunctions implementations."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- III.TYPE SYSTEMSAn entity name referred out of its scope gets resolved according to specific scoping rules. Names in nested scopes get resolved through declarations from inner to outer scopes. Thismay involve resolving one or more namespaces, then - a classname to a context, and then - the member name within thatcontext. A fully qualified name lists all these scoping names- e.g., via a dot notation (java.lang.Math.sin(x);). Itunambiguously specifies which object, function, or data typeis being referred even when out of its declaration scope.The listed names play the role of name qualifiers. The TypeSystem applies the proper qualifiers when a using (import/include) statement is specified."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- III.TYPE SYSTEMSAfter an entity name is resolved, it gets bound appropriately: for an object - its data type and its data are bound; for a function - its return type and its parameters' types are bound.A function is called with resolved and bound arguments(actual parameters); then its implementation is bound."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- III.TYPE SYSTEMSAn object or a function must be completely resolvedbefore it is used. In the case of a polymorphic object,the Type System resolves it also among the correspondinghierarchical structure. In the case of a polymorphic function,the Type System resolves it based on its type arguments(generics), its invoking object data type (overriding), or itssignature (overloading). The type argument, the dynamicobject data type, or the arguments or function declarations,may correspondingly be a problem. In most programminglanguages, generics and function/operator overloading areresolved at compile-time (early binding and ad-hoc binding,correspondingly) and virtual methods overriding is resolvedat run-time (late binding)."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- III.TYPE SYSTEMSA resolved and bound object may be converted to another data type and used in computations. Conversions couldbe explicit - casting, or implicit - coercion. Computations could be calculation of arithmetic expressions or evaluationof boolean expressions. Arithmetic expressions are used tocalculate for example how much memory to allocate, the sizeof a structured object, or the position of an index. Pointerarithmetics and pointer scaling may be used to calculateposition of pointer or memory address. Boolean expressionsare used to evaluate conditions."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- IV.DATA TYPE BUGS MODELData Type bugs could be introduced at any of the declaration, name resolution, data type conversion, or data type related computation phases. Each data type related bug orweakness involves one data type operation: Declare, Define,Refer, Call, Cast, Coerce, Calculate, or Evaluate."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- IV.DATA TYPE BUGS MODELThe BF Data Type Bugs model helped usidentify the phases and the operations where such bugs couldoccur. The phases correspond to the BF Data Type Bugsclasses: Declaration Bugs (DCL), Name Resolution (NRS),Type Conversion Bugs (TCV), and Type Computation Bugs(TCM). All data type operations are grouped by phase"
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- IV.DATA TYPE BUGS MODELThe operations under DCL (The BF Data Type Bugs model) are on declaring entities names and on defining objects data and functions implementations: Declare and Define. See definitions of DCL operations in Table Ia."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- IV.DATA TYPE BUGS MODELThe operations under NRS (The BF Data Type Bugs model) are on resolvingreferred entities names and on binding their data types and theobjects data, and on resolving called functions and bindingtheir implementations: Refer and Call. See definitions ofNRS operations in Table Ib. The NRS operations are tiedto the name resolution and binding that the Type Systemperforms. Note that the object data value is bound via the Initialize and Writeoperations of the BF Memory Use Bugs (MUS) class."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- IV.DATA TYPE BUGS MODELThe operations under TCV (The BF Data Type Bugs model) are on explicit conversion and on implicit conversion into a different data type of a passed data value in/out of a function: Cast and Coerce. See definitions of TCV operations in Table Ic."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- IV.DATA TYPE BUGS MODELThe operations under TCM (The BF Data Type Bugs model) are on calculating anarithmetic operation (part of an algebraic expression) and onevaluating a boolean operation (part of a condition): Calculateand Evaluate. See definitions of TCM operations in Table Id."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- IV.DATA TYPE BUGS MODELThe possible flow between operations from differentphases is depicted in The BF Data Type Bugs model with arrows. A declared anddefined entity is referred in source code via its name. Names, referred to in remote scopes, get resolved via resolved namespaces; resolved data types get bound to objects, functions, or generic data types according to their declarations (see the purple arrow flow). A resolved and bound object may be converted to another data type and used in computations asan argument or as a return of a called function, or to calla member function. A passed in argument is expected tobe of the declared parameter data type and the passed outresult is expected to be of the return data type. Otherwise,casting (explicit conversion) is expected before or at the endof the call (see the blue arrows flow), or the value will getcoerced (implicitly converted) to the parameter data type orthe return data type, correspondingly (see the green arrowsflow). Note that the green arrows flow is only about coercedpassed in/out objects - it starts only from NRS Call, it neverstarts from DCL Declare. The presented operations flow helpsin identifying possible chains of bugs and weaknesses."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESWe define the BF Data Type Bugs in 4 classes as follows:(1) Declaration Bugs (DCL) namely an object, a function, a datatype, or a namespace is declared or defined improperly.(2) Name Resolution Bugs (NRS) namely the name of an object, a function, or a data type is resolved improperly or boundto an improper data type or implementation.(3) Type Conversion Bugs (TCV) namely a data value is cast orcoerced into another data type improperly.(4) Type Computation Bugs (TCM) namely an arithmetic expression(over numbers, strings, or pointers) is calculated improperly, or a boolean condition is evaluated improperly."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESEach of these classes represents a phase, aligned withthe Data Type Bugs model (The BF Data Type Bugs model), and is comprised of setsof operations, cause??consequence relations, and attributes,allowing precise causal descriptions of bugs/weaknesses inthe declaration or definition of an object, a function, or adata type, the resolution of their names, the binding of theirtypes or implementations, or of any type related conversionsand computations"
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESA. OperationsAll BF classes are being designed to be orthogonal; theirsets of operations do not overlap. The operations in whichdata type bugs could happen (defined in Table I) correspondto the operations in the BF Data Type Bugs model (The BF Data Type Bugs model)."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESA. OperationsThe DCL operations are Declare and Define. They reflectthe improper declaration or definition of an object, a function,a data type, or a namespace. The NRS operations are Referand Call. They reflect the improper name resolution, and datatype, data, or implementation binding. The TCV operations are Castand Coerce. They reflect the improper use of data types in object data value conversion to another data type. The TCM operations are Calculateand Evaluate. They reflect the improper use of data types in arithmetic calculations and condition evaluations."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESB. CausesA cause is either an improper operation or an improperoperand. If a BF class instance is the first in a chain,describing a vulnerability, it is always caused by an improperoperation or an improper operation rule. The values forimproper data type related operations are Missing, Wrongand Erroneous. The possible operation rules are ImproperModifier and Improper Scope. The values for these arecorrespondingly: Missing Modifier and Wrong Modifier; andAnonymous Scope, Wrong Scope, Missing Qualifier, andWrong Qualifier. See definitions and examples in Table II."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESB. CausesThe possible operands of a Data Type operation are:Data Value, Data Type, and Function. See definitions in Table III. All values for an improper operand of a data type operation are defined in Table IV."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESB. CausesAll possible causes for data type bugs are defined inTable II and Table IV. "
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESC. ConsequencesA consequence is either a final error or a wrong resultfrom the operation that propagates as an improper operand for a next weakness."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESC. ConsequencesThe possible improper operands as consequences fromdata type bugs classes are Improper Data Value, ImproperData Type, and Improper Function. All their possible valuesare defined in Table IV. As a consequence, they wouldbecome causes for operations of next weaknesses. Theseconsequence/cause transitions explain why some appear bothas causes and as consequences."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESTABLE I: Operations(a) DCL (Declaration)The DCL operations are Declare and Define. The operation value named Declare is defined by when you Specify name and data type of an object; name, return data type, and parameters of a function; or name and typeparameters of a data type. May specify modifiers for requiredbehaviour restrictions.The operation value named Define is defined by when you Specify data of an object; implementation of a function; or member objects and functions of a type."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESTABLE I: Operations(b) NRS (Name Resolution)The NRS operation are Refer and Call. The operation value named Refer is defined by the usage of a name in local or remote scopes of source code. The Type System resolves the name and binds a data type to it. The operation value named Call is defined by when you invoke a function implementation. The Type System bindsthe implementation to the resolved function name. A polymorphic implementation is first resolved and then bound."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESTABLE I: Operations(c) TCV (Conversion)The TCV operations are Cast and Coerce. The operation value named Cast is defined by the explicitly convert the value of an object to another data type. The operation value named Coerce is defined by the Implicitly (forced by the Type System) convert the value ofa passed in/out argument or the return into the corresponding parameter or return data type. (Type Coercion is known alsoas Type Juggling.)"
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESTABLE I: Operations(d) TCM (Computation)The TCM operations are Calculate and Evaluate. The operation value named Calculate is defined by when you find the result of a numeric, pointer, or string operation. The operation value named is defined by when you find the result of a boolean condition (incl. comparison)."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESD. AttributesAn attribute provides additional useful information aboutthe operation or its operands. All possible attributes for datatype bugs are defined in Table VI. The operation attributeSource Code explains where the bug is in the program.The operand attribute Data Type Kind explains the datatype structure. See definitions of these attributes values inTable VIa."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESD. AttributesEach of DCL, NRS, TCV, and TCM also have theoperation attribute Mechanism but with different possiblevalues, specific to the particular data type operations. Seedefinitions of this attribute values in Table VIb, Table VIc,Table VId, and Table VIe."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESD. AttributesDCL and NRS also have the operand attribute Entity,which explains what is being declared or resolved. See thedefinition of this attribute value in Table VIf."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESD. AttributesTCV and TCM also have the operand attribute DataValue Kind, which explains the actual data value. See itsdefinition in Table VIg."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESE. SitesA site for data type bugs is any part of the code forwhich the Type System checks explicit typing rules or applies implicit typing rules."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESE. SitesDCL sites are the entities declarations and definitions.NRS sites are the entities references and the function calls.TCV sites are the cast operators and the in/out argumentpassing and return statements. TCM sites are the arithmetic,bitwise shift, concatenation, pointer arithmetics, pointer scaling, relational, and boolean operators."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESTABLE II: Improper OperationThe improper operation named Missing is defined by when the operation is absent for example Missing constructor , +(int,double) overload, function override in subtype. The improper operation named Wrong is defined by An inappropriate data type is specified; or an inappropriate function/operator is used for example an object is declared int while it should be float or a class implements a cloneable or a serializable interface.The improper operation named Erroneous is defined by The Type System or a compute function implementation has a bug for example Incorrect data type inference, Wrong order/number of arguments to a function call and Incorrect deep objects comparison implementation."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESTABLE II: Improper OperationThe improper operation value named Missing Modifier is defined by A required behavioral restriction is absent for example Access: public, private, protected, internal or Type: long, long long, short,unsigned,signed. The improper operation value named Wrong Modifier is defined by a wrong behavioral restriction is specified for example the use of private instead of protected modifier. The improper operation value named Anonymous Scope is defined by The declaration is in an unnamed scope for example an inner class. The improper operation value named Wrong Scope is defined by the declaration should be in another scope for example an object declared as local, while it should be global. The improper operation value named Missing Qualifier is defined by a namespace include is absent; or a scope is not specified in a fully qualified name for example a user defined method with same name is invoked instead of a needed library one. The improper operation value named Wrong Qualifier is defined by a wrong namespace is included, or a wrong scope is specified in a fully qualified name for example the use of math.log instead of numpy.log when the second one is needed."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- V. DATA TYPE BUGS CLASSESTABLE III: OperandsThe operand concept named Data value is defined by a numeric, text, pointer/address, or boolean value stored in an object's memory. The operand concept named Data Type is defined by set of allowed values and the operations allowed over them. The operand concept named Function is defined by an organized block of code that when called takes in data, processes it, and produces a result(s)."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSION In this section, we analyze the correspondence of thedata type related CWEs, such as Numeric Errors,Type Errors, and String Errors, to the four newlydeveloped BF Data Type Bugs classes. We show that DCL,NRS, TCV, and TCM cover all data type related CWEs, andpotentially beyond, while (as demonstrated in Section VII)providing a better structured way for describing these kindsof bugs/weaknesses."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSION TABLE IV: Improper Operand(a) Improper Data ValueThe improper Data Value named Under Range is defined by Data value is smaller than type's lower range. The improper Data Value named Over Range is defined by when Data value is larger than type's upper range. The improper Data Value named Flipped Sign is defined by when sign bit is overwritten from type related calculation. The improper Data Value named Wrong Argument Value is defined by inaccurate input data value.The improper Data Value named Wrong Object Resolved Value is defined by when the Object is resolved from wrong scope. The improper Data Value named Reference vs Object is defined by the Object's address instead of object's data value. The improper Data Value named Wrong Result is defined by the incorrect value from type conversion or computation. The improper Data Value named Wrap Around is defined by a moved around-the-clock value over its data type upper or lower range, as it exceeds that range. The improper Data Value named Truncated Value is defined by the Rightmost bits of value that won't fit type size are cut off. The improper Data Value named Distorted Value is defined by an incorrect value (although fits type size) due to sign flip or signed/unsigned and vice versa conversions. The improper Data Value named Rounded Value is defined by a real number value precision loss."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSION TABLE IV: Improper Operand(b) Improper Data TypeThe improper Data Type named Wrong Type is defined by when the Data type range or structure is not correct. The improper Data Type Wrong Type Resolved is defined by when the Data type is resolved from wrong scope. The improper Data Type named Wrong Object Resolved Type is defined by when the object is resolved from wrong scope,so it's data type might be wrong. The improper Data Type named Wrong Sign Type is defined by the unsigned instead of signed data type is specified or vise versa.The improper Data Type named Wrong Precision Type is defined by when Higher precision data type is needed. The improper Data Type named Incomplete Type is defined by a Specific constructor, method, or overloaded function is missing. The improper Data Type named Mismatched Argument Type is defined by an Argument's data type is different from function's parameter data type. The improper Data Type named Wrong Generic Type is defined by when a Generic object instantiated via wrong type argument. The improper Data Type named Confused Subtype is defined by Object invoking an overriden function is of wrong subtype data type. The improper Data Type named Wrong Argument Type is defined by when the Argument to an overloaded function is of wrong data type."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSION TABLE IV: Improper Operand(c) Improper FunctionThe improper function named Missing Overridden Function is defined by when the Function implementation in a particular subclass is absent. The improper function named Missing Overloaded Function is defined by when the implementation for particular function parameters' data types is absent. The improper function named Wrong Function Resolved is defined by when the function is resolved from wrong scope. The improper function named Wrong Generic Function Bound is defined by the implementation for a wrong data type is bound due to wrong generic type arguments. The improper function named Wrong Overridden Function Bound is defined by the implementation from wrong subtype is bound due to a wrong invoking subtype object.The improper function named Wrong Overloaded Function Bound is defined by when the wrong overloaded implementation is bound due to wrong function arguments."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSION TABLE V: Data Type Errors(a) Access Errors - as DCL ConsequencesThe access error value named Wrong Access Object defined by an unauthorized access to an object exposes sensitive data or allows access to member functions. The access error value named Wrong Access Type is defined by an unauthorized access to a data type allows access to member objects and functions. The access error value named Wrong Access Function is defined by unauthorized access to a function."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSION TABLE V: Data Type Errors(b) Type Compute Errors - as TCM ConsequencesThe Type Compute Error value named Undefined is explained by the Type System cannon represent the computation result."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSION TABLE VI: Attributes(a) DCL, NRS, TCM, and TCV AttributesThe operation attribute named Source code has four values. The first value named Codebase is defined by the operation is in the programmer's code - in the application itself. The second value named Third Party is defined by when the operation is in a third-party library. The third value named Standard Library is defined by when the operation is in the standard library for a particular programming language. The fourth value named Compiler/Interpreter is defined by when the operation is in the language processor that allows execution or creates executables (compiler, assembler, interpreter).The operand attribute Data Type Kind has two values, the Primitive and the Structured. The value named Primitive mimics the hardware units and is not built from other data types for example int (long, short, signed), float, double, string, boolean. The value named Structured builds of other data types; have members of primitive and/or structured data types for example array, record, struct, union, class, interface."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSION TABLE VI: Attributes(b) DCL AttributeThe DCL have the operation attribute named Mechanism with four values. The firt value named Simple is defined by a non-polymorphic entity. The second value named Generics is defined by an entity parameterized by type. The third value named Overriding is defined by functions with the same name as one in the basetype, but implemented in different subtypes. The fourth value Overloading is defined by functions with the same name in the same declaration scope, but implemented with differentsignature."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSION TABLE VI: Attributes(c) NRS AttributeThe NRS have the operation attribute named Mechanism with five values. The first value named Resolve is defined by look up entity name and if needed determine data type. The second value named Bind is defined by the connect object data type, function return type, parameter data type, or simple function implementation. The third value named Early Bind is defined by resolve subtype and set generic function implementation. The fourth value named Late bind is defined by resolve overriden function via subtype object and set implementation. The fifth value named Ad-hoc Bind is defined by resolve overloaded function via signature and set implementation."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSION TABLE VI: Attributes(d) TCV AttributeThe TCV have the operation attribute named Mechanism with two values. The first value named Pass in is defined by supply in arguments data values to a function/operator. The second value named Pass out is defined by supply ""out"" or ""in/out"" arguments' data values or a return value to a function/operator."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSION TABLE VI: Attributes(e) TCM AttributeThe TCM have the operation attribute named Mechanism with five values. The first value named Function is defined by an organized block of code that when called takes in data, processes it and returns a result. The second value named Operator is defined by a function with a symbolic name that implements a mathematical, relational or logical operation. The third value named Method is defined by a member function of an OOP class. The fourth value named Lambda Expression is defined by an anonymous function, implemented within another function. The fifth value named Procedure is defined by a function with a void return type."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSION TABLE VI: Attributes(f) DCL and NRS AttributesThe DCL and NRS have the operation attribute named Entity with four values. The first value named Object is defined by a memory region used to store data. The second value named Function is defined by an organized block of code that when called takes in data, processes it and returns a result. The third value named Data Type is defined by a set or a range of values and the operations allowed over them. The fourth value named Namespace is defined by an organization of entities' names, utilized to avoid names collision."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSION TABLE VI: Attributes(g) TCV and TCM AttributeThe TCV and TCM have the operation attribute named Data Value Kind with four values. The first value named Numeric is defined by a number stored in an object's memory. The second value named Text is defined by a  string stored in an object's memory. The third value named Pointer is defined by a holder of the memory address of an object. The fourth value named Boolean is defined by A truth value (true or false; 1 or 0), stored in an object's memory."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSION We identified data type related CWEs in three steps: 1)CWE Filtering: Since different types of bugs/weaknesses are described in CWE, we filtered a set of CWEs which descriptions contain keywords such as ""type"", ""string"", ""class"", ""cast"", and ""compare"". 2) Automated Extraction: Starting from the filtered CWEs and following their parent-childrelationships, we extracted all the clusters of potentially data type related CWEs. 3) Manual Review: All the authors, who are a team of professional security researchers, performed iterative rounds of manual CWE reviews, identifying the type related CWEs among the extracted CWE clusters. Finally, we could collect 84 CWEs, 78 of which are data type related. The additional six CWEs: 573, 664, 668, 710, 758, and 1076 (shown with gray outline) were included only for parent-child completeness. We peer-reviewed their detailed descriptions, examples, and listed CVEs, as well as the corresponding literature; and performed weekly discussions brainstorming to confirm each of these CWEs is covered by the operations, causes, and/or consequences defining the BF Data Type Bugs classes."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSION We mapped each of the identified CWEs to a BF DataType Bugs class based on the operations that are definedin DCL, NRS, TCV, and TCM and identified an operationfor the CWE. Then, we generated digraphs of all data typerelated CWEs to show their correspondence to the BF DataType Bugs classes by operation (A digraph of the data type related CWEs, mapped by DCL, NRS, TCV, and TCM operations) and by consequence (digraph of the data type related CWEs, mapped by BF DCL, NRS, TCV, and TCM consequences). In the digraphs, each node is a CWE weakness, shown by its CWE ID, and the edges show the parent/child relationship. The outline style of a CWE node indicates the abstraction level: pillar, class, base, or variant."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSION Most of the CWEs, visualized on the digraph of the data type related CWEs, mapped by DCL, NRS, TCV, and TCM operations, are covered by the DCL class. They relate to improper declarationand definition of structured data and are under the pillars CWE-664 (Improper Control of a Resource Through its Lifetime) and CWE-668 (Exposure of Resource), and CWE-710 (Improper Adherence to Coding Standards), correspondingly."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSIONTwo other large clusters of data type related CWEs are covered by TCM. They relate to improper calculationand evaluation and are descendants of the pillars CWE682 (Incorrect Calculation) and CWE-697 (Incorrect Comparison), correspondingly. Two of the CWE-628 (Function Call with Incorrectly Specified Arguments) descendants are also covered by TCM Calculate and Evaluate. In addition, CWE-351 (Insufficient Type Distinction) is covered by TCM Evaluate."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSIONThe CWEs covered by TCV are under CWE-704 (Incorrect Type Conversion or Cast). They mostly relate toimproper coercion - CWE-843 (Access of Resource Using Incompatible Type ('Type Confusion')) and the children of CWE-681 (Incorrect Conversion between Numeric Types). Only one CWE was identified as improper casting - CWE588 (Attempt to Access Child of a Non-structure Pointer)."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSIONOnly a few CWEs are partly related to the NRS class, which is surprising as bugs related to polymorphic calls are not rare. Our explanation is that CWE considers improper name referring/resolving and improper function calling/binding to be part of a computation weakness. For instance, CWE-468 is under CWE-682 (Incorrect Calculation), but it lists an example that starts with a TCV bug leading to an NRS weakness, and is actually a five weaknesses chain (see the BF description in section VII-B)."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSIONA diagram of the percentages of data type related CWEs by the operations of the BF Data Type Bugs classes shows the percentages of data type related CWEs by BF class operation. It shows that most of these CWEsare about weaknesses that occur at declaration and definition (50% combined) of objects, types, and functions. Next are weaknesses related to performing data type related calculations or evaluations (33.3% combined). The least represented are the name resolution (at refer and call) and type conversion(at cast and coerce) weaknesses."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSIONWhile the CWEs only enumerate weaknesses, the Data Type Bugs classes ensure precise descriptions, as a weakness is described via one cause, one operation, and one consequence. The CWEs exhaustive list is prone to gaps in coverage and some weakness types may be missing. For example, in the type related categorization the CWEs are mainly focused on primitive data type errors, such as Numeric Errors and String Errors, while our developed BF classes consider both primitive and structured data types. Besides that, the data type related CWEs focus mostly on types of errors that happen during arithmetic calculations and comparison evaluations, while the BF Data Type Bugs classes define type related bugs based on different stages of the data types development: from declaration and definition to resolution and usage."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSIONThe BF Data Type Bugs classes present a taxonomy with structured cause/consequence relations that is complete and orthogonal. It could be viewed as a structured extension over the CWEs related to Wrong Result, Rounded Value, Truncated Value, Wrap Around (incl. Integer Overflow), Under Range, Over Range Flipped Sign, Wrong Access, and Undefined Behaviour. It is a taxonomy that explains the causal relationships between weaknesses and would be easier to use than the nested hierarchical CWEs."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VI.BF DATA TYPE BUGS TAXONOMY AS CWE EXTENSIONMany bug reporting tools use the CWE to describe detected bugs/weaknesses. As a structured extension over the data type related CWEs, the BF Data Type Bugs taxonomy can be used to report identified data type related bugs/weaknesses (including those leading to integers overflow, juggling, and pointer arithmetic errors). The digraph of the data type related CWEs, mapped by DCL, NRS, TCV, and TCM operations shows how data type related CWEs translate to BF DCL, NRS, TCV, TCM by operation; Compared to digraph of the data type related CWEs, mapped by BF DCL, NRS, TCV, and TCM consequences which show how they translate by consequences."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VII. SHOWCASESIn this section, we use the new BF Data Type Bugs classes for precise descriptions of software vulnerabilities. We also provide the fixes of each bug."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VII. SHOWCASESA. CVE-2021-21834 and the Bad Allocation ChainOur first example is an instance of a BF Chain that defines a pattern (""BadAlloc"") observed by CISA and reported in its Industrial Control Systems Advisorys, ICSA-21-119-04. The advisory lists 25 similar vulnerabilities found in multiple real-time operating systems."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VII. SHOWCASESA. CVE-2021-21834 and the Bad Allocation ChainUsing the BF classification, we describe BadAlloc as a DVR- TCM- MAL ? MAD ? MUS chain. That is, due to improper verification (DVR), an attacker can craft an input that creates an integer overflow (TCM), leading to allocation (or reallocation) of an undersized buffer (MAL). Therefore, a pointer can be moved overbounds (MAD), leading to a buffer overflow error (MUS). This vulnerability could lead to a failure, such as denial of service or, even worse, (remote) code execution."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VII. SHOWCASESA. CVE-2021-21834 and the Bad Allocation ChainTo clearly illustrate how this pattern happens, we describe in detail CVE-2021-21834 that occurs in an opensource project. It was identified by the Cisco Talos team. "
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VII. SHOWCASESA. CVE-2021-21834 and the Bad Allocation Chain1) Brief Description: The GPAC Project on AdvancedContent is a C language implementation of the MPEG4 audio/video compression standard. In version 1.0.1, thelibrary is vulnerable to decoding a specially crafted MPEG-4input file"
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VII. SHOWCASESA. CVE-2021-21834 and the Bad Allocation Chain2) Analysis: The library code reads the ""number of entries"" value from a file into the 32-bit integer object(ptr?nb_entries) and checks if it is not larger than the 64- bits input size (ptr?size/8). Then, the size of memory that should be allocated is calculated by multiplying the ""number of entries"" by the size of a u64 object (sizeof(u64)), which can result in an integer overflow on a 32-bit platform. When such an overflowed integer is used, the allocation routine will create an undersized buffer, which will be populated based on its larger actual size, leading to a buffer overflow."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VII. SHOWCASESA. CVE-2021-21834 and the Bad Allocation Chain3) The Fix: To fix the bug, the GPAC team checked the maximum integer size ((u64)ptr?nb_entries > (u64)SIZE_MAX/sizeof(u64)), fixing the DVR bug and resolving the entire vulnerability."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VII. SHOWCASESB. CWE-468, Example 1 - Incorrect Pointer ScalingOur second example is a pointer scaling bug, illustrating how a simple piece of code could have a bug and several weaknesses behind it. This is a common C/C++ pointer bug; it happens when a programmer miscalculates a pointer increment (or decrement) by a fraction of its type size (for example attempting to move an int pointer one byte to the right)."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VII. SHOWCASESB. CWE-468, Example 1 - Incorrect Pointer ScalingCWE-468 provides an excellent two lines of code example: int *p = x; char * second_char = (char *)(p + 1); ."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VII. SHOWCASESB. CWE-468, Example 1 - Incorrect Pointer Scaling1) Analysis: The chain starts with an improper casting of the pointer p to char * that leads to invocation of a wrong addition operator6 int* + 1 instead of char* + 1. Therefore, the pointer moves 4 bytes instead of 1 byte (3 bytes off), reading the wrong value, outside the object x (buffer overflow). Fig.11 presents the BF taxonomy for this weakness."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VII. SHOWCASESB. CWE-468, Example 1 - Incorrect Pointer Scaling2) The Fix: To fix the bug, the programmer should first cast and then add: int *p = x; char * second_char = (char *)p + 1; ."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VII. SHOWCASESC. CVE-2021-23440 and Type Mismatch bypassing Input ValidationOur third example illustrates again a pattern of weaknesses that appears in different vulnerabilities. This pattern is described by the same BF chain. Type mismatch bugs are common in languages that have different operators for loose comparison and strict comparison, such as JavaScript and PHP. In this bug, the programmer uses a loose comparison when it should be a strict comparison, leading to inputvalidation bypass."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VII. SHOWCASESC. CVE-2021-23440 and Type Mismatch bypassing Input ValidationUsing the BF classification, we describe this pattern of vulnerabilities via two BF chains. The first is an one-class chain, TCM (improper comparison: loose instead of strict). The second is a two-classes chain, TCV ? DVL. That is, due to missing type conversion an improper validation (DVL) happens, allowing an attacker to create an injection error. This vulnerability could lead to a failure, such as denial of service or, even worse, (remote) code execution."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VII. SHOWCASESC. CVE-2021-23440 and Type Mismatch bypassing Input ValidationOne concrete example is CVE-2021-23440. It was discovered by the Snyk Team with several other loose comparison bugs."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VII. SHOWCASESC. CVE-2021-23440 and Type Mismatch bypassing Input Validation1) Brief Description: The package set-value for JavaScript is vulnerable to prototype pollution in versions <2.0.1, >=3.0.0, <4.0.1. It happens due to a type mismatch in the prototype pollution verification."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VII. SHOWCASESC. CVE-2021-23440 and Type Mismatch bypassing Input Validation2) Analysis: This vulnerability has two possible BF chains. The first chain is: the loose comparison operator is misused. The second chain is: a type conversion is missing before using the loose comparison, leading to improper input validation and prototype pollution, a kind of command injection in JavaScript."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VII. SHOWCASESC. CVE-2021-23440 and Type Mismatch bypassing Input Validation3) The Fix: There are two ways of fixing this vulnerability: the developers could use strict comparison, solving the TCM bug, or they could do a type conversion before the loose comparison. They chose the latter."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VIII. RELATED WORKSThe Bugs Framework (BF) is concerned with securityrelated bugs, for example bugs that open doors for exploitation. The work of X.Sun (How security bugs are fixed and what can be improved: An empirical study with mozilla) is the only one we found to establish a taxonomy classifying Data Type related security bugs. The classes in their taxonomy are called Fix Patterns. Although their paper is succinct, we understand that at least two Fix Patterns relate to the BF Data Type Bugs classes: COP (changing the type of an object to its parent class) and COS (changing the type of an object to its subclass) are related to TCV. Several other authors attempted to create successful taxonomies of bugs/weaknesses that lead to security failures."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VIII. RELATED WORKSZ.Hui reviewed them in ""Review of Software Security Defects Taxonomy"". Unfortunately, none of those taxonomies tackle the specific problem of data type bugs. However, we identified several publications that discuss some of the underlying weaknesses of type-related vulnerabilities, such as type confusion, loose comparison, integer overflow and type mismatch."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VIII. RELATED WORKSType confusion vulnerabilities happen when a pointer is converted from a subclass pointer to a base class pointer. Their BF descriptions usually contain a NRS or a TCV class. I.Haller (see Typesan: Practical type confusion detection) studied this kind of bugs and developed TypeSan, a practical type confusion detector for C++ language."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VIII. RELATED WORKSLoose comparison vulnerabilities happen when the developer wrongly uses the loose comparison feature of dynamically typed languages such as PHP and JavaScript. Their BF descriptions could be related to all BF Data Type Bugs classes. P.Li (see ""Lchecker: Detecting loose comparison bugs in php) studied loose comparison bugs in PHP and proposed LChecker to detect this kind of bugs in PHP code."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VIII. RELATED WORKSType mismatch vulnerabilities happen when an in argument or a return variable has an unexpected type. They also happen due to improper declarations. Their BF descriptions could be related to all BF Data Type Bugs classes. Z.Gao (see To type or not to type: Quantifying detectable bugs in javascript) have discussed type mismatch bugs and performed a detailed quantification of static type systems for JavaScript. M.Pradel (see Typedevil: Dynamic type inconsistency analysis for javascript) also studied type mismatches in JavaScript and proposed a tool (TypeDevil) to detect it. L.Pascarella (see Investigating type declaration mismatches in python) investigate how inconsistent documentation can lead to type mismatch bugs in Python."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VIII. RELATED WORKSInteger overflow vulnerabilities happen when a congruent arithmetic operation (modulo 2 n, for a n-bit integer) wraps around. Their BF descriptions relate to the TCM class. W.Dietz (see Understanding integer overflow in c/c++) reviewed integer overflow in C/C++ language. Their work gives a good picture of the issue."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VIII. RELATED WORKSAlthough, the aforementioned papers have studied the bugs and weaknesses discussed in this paper, our work is considerably different. The current literature focuses on tools and procedures to detect a particular bug/weakness, while we are focusing on the theoretical side of all this. We are developing a classification system for all possible kinds of data type bugs/weaknesses and a methodology to describe the interrelationship between those kinds of weaknesses and other ones, such as memory corruption bugs and improperly checked input bugs. We believe that such a structured model for software bugs will allow the development of better automatic tools in the future."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- VIII. RELATED WORKSIn addition to CWE, to the best of our knowledge, there is no attempt to describe data type bugs/weaknesses. The relationship between the data type related CWEs and the BF classes are presented in section VI."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- IX. CONCLUSIONIn this paper, we introduce four new BF classes: Declaration Bugs (DCL), Name Resolution Bugs (NRS), Type Conversion Bugs (TCV), and Type Computation Bugs (TCM). We present their operations, possible causes, consequences, attributes, and sites. We show how they cover all CWEs related to conversion, calculation (incl. comparison), wraparound (incl. integer overflow), pointer scaling, coercion (juggling), and other data type related weaknesses. We analyze particular data type vulnerabilities and provide their preciseBF descriptions. The BF structured taxonomies show the initial error in code (the bug), providing a quite concise and still far more clear description than the unstructured explanations in current repositories, advisories, and publications. The BF Data Type Bugs taxonomy can be used by bug reporting tools, as it is a structured extension over the data typerelated CWEs. To our knowledge there is no other bug taxonomy that allows precise causal descriptions of data type related declaration, resolution, conversion, and computation bugs/weaknesses."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- IX. CONCLUSIONFuture work should identify and describe more CVEs related to data type related declaration, resolution, conversion, and computation bugs/weaknesses, evaluating the BF Data Type Bugs taxonomy for usability. In such an evaluation, a machine learning algorithm or multiple analysts would classify and describe newly reported bugs, while helping improve BF's taxonomy by fine-tuning the classes."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- IX. CONCLUSIONBF has the expressiveness power to clearly describe any software bug or weakness, underlying any vulnerability. Precise BF descriptions of software vulnerabilities as chains of bug-weaknesses-failure will allow clear communication among software developers, testers, IT professionals, and IT managers. The vulnerability databases, such as NIST NVD and CISA KEV, will have CVE entries in machine readable formats that cybersecurity researchers can use for building code review tools and for a broad spectrum of ML and AI systems for detection of software vulnerabilities and exploring complex malicious attacks. This will aid better software development/coding practices, mitigation designs, automated cybertesting capabilities, and will greatly advance our way of securing the cyberspace and the critical infrastructure. The BF taxonomy will allow clear explanations of what happens in a vulnerability to IT professionals and non-IT executives, as well as researchers, developers, and students. It will support development of precise software testing tools with unambiguous reports."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- IX. CONCLUSIONBF aims to provide more than a classification system. It is a model of the underlying weaknesses, describing a sequence of causes and consequences, starting with the bug (the defect) to the final failure (the exploit). Although the entire framework is not ready yet, we believe that providing a model of the underlying weaknesses helps to clarify if a bug has been fixed or just mitigated, allowing correct risk assessment of vulnerabilities and minimizing incomplete fixes. A taxonomy providing cause/consequence relations should improve bug reports of security-related bug"
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- IX. CONCLUSIONThe CWE digraphs by BF class consequences should be deeply analyzed. Generation of digraphs with CWEs related to particular software errors (for example wrap-around), detecting corresponding clusters and understanding their relationships would create a comprehensive view of the CWE model for researchers and practitioners. In turn, comparing and contrasting the CWE's exhaustive list of weaknesses with all the possible consequence-cause transitions to other BF classes would improve BF as a tool for describing CVEs."
"Data Type Bugs Taxonomy: Integer Overflow,Juggling, and Pointer Arithmetics in Spotlight- IX. CONCLUSIONWe will continue developing orthogonal BF classes that cover and extend the CWE weakness types. The ultimate goal for BF is to help IT professionals understand how software vulnerabilities originate from bugs, propagate through weaknesses, and end as failures. The gain would be fewer bugs, fewer vulnerabilities, less time to fix/patch code, and better tools for bugs detection."
"Heartbleed Revisited: Is it just a Buffer Over-Read- AbstractIn this work, we analyse in detail the weaknesses underlying the Heartbleed vulnerability, CVE-2014-0160, and show why and how highly sensitive information could be exposed via buffer over-read."
Heartbleed Revisited: Is it just a Buffer Over-ReadHeartbleed was a serious vulnerability in the popular OpenSSL cryptographic software library. The fatal bug was in the Heartbeat Extension of the TLS (Transport Layer Security) protocol implementation. The vulnerability was disclosed in April 2014 with the following Common Vulnerabilities and Exposures (CVE) entry.
"Heartbleed Revisited: Is it just a Buffer Over-ReadCVE-2014-0160: ""The TLS and DTLS implementations in OpenSSL 1.0.1 before 1.0.1g do notproperly handle Heartbeat Extension packets, which allows remote attackers to obtain sensitive informationfrom process memory via crafted packets that trigger a buffer over-read, as demonstrated by reading privatekeys, related to d1_both.c and t1_lib.c, aka the Heartbleed bug."
"Heartbleed Revisited: Is it just a Buffer Over-ReadAttacks exploiting Heartbleed, can reveal highly sensitive information - such as private keys, user logincredentials, and business or personal information - via reads over the buffer bounds (for example buffer over-reads). Heartbleed's name literally means a server (or a client) with a vulnerable Heartbeat Extension can ""bleed"" data via heartbeat response messages. A small heartbeat message with a large requested length can reveal up to 64KB raw memory, and multiple requests can accumulate huge amounts of data."
"Heartbleed Revisited: Is it just a Buffer Over-ReadFor the lack of a more precise Common Weakness Enumeration (CWE) entry, the National Vulnerability Database (NVD) assigns to CVE-2014-0160 and CWE-119 ""Improper Restriction of Operations within the Bounds of a Memory Buffer"", which covers both underbounds and overbounds, and both reads and writes to or from a buffer. However, we can describe it precisely utilizing the National Institute of Standards and Technology (NIST) Bugs Framework (BF). We will use the BF Data Verification (DVR), Memory Addressing (MAD), and Memory Use (MUS) classes to describe Heartbleed at a level of detail allowing clear understanding of its underlying bugs, chains of weaknesses, and exploitable errors."
"Heartbleed Revisited: Is it just a Buffer Over-ReadIn this article, we analyze the Heartbleed code and clearly describe how Heartbleed leadsto buffer over-read. We also examine what else is needed for such buffer over-reads to cause exposureof sensitive information."
"Heartbleed Revisited: Is it just a Buffer Over-Read -THE BUGS FRAMEWORK (BF)We are developing the NIST Bugs Framework (BF) as a structured, complete, orthogonal classificationsystem of software security bugs and weaknesses, which is also language and domain independent. BFconsists of a set of bug/weakness class taxonomies and a formal language for describing software securityvulnerabilities."
"Heartbleed Revisited: Is it just a Buffer Over-Read -THE BUGS FRAMEWORK (BF)A BF class is a taxonomic category of a weakness type, defined by a set of operations - where suchbugs could happen, a set of causes - the possible improper operations (bugs) and improper operands(faults), a set of consequences - the possible errors (that become faults for next weaknesses) and thepossible final errors (that become exploits), a matrix of valid cause/operation/consequence relations, and a set of attributes for the operations and the operands."
"Heartbleed Revisited: Is it just a Buffer Over-Read -THE BUGS FRAMEWORK (BF)The BF formal language adheres to our BF vulnerability model, according to which a vulnerability description is a chain of underlying weaknesses leading to a security failure."
"Heartbleed Revisited: Is it just a Buffer Over-Read -THE BUGS FRAMEWORK (BF)In this work, we describe the Heartbleed vulnerability utilizing the taxonomies of the BF DVR, MAD, and MUS classes. DVR relates to how input data semantics is checked or corrected. MAD relatesto how an object pointer is initialized, repositioned, or reassigned. MUS relates to how an object is initialized, read, written, or cleared."
"Heartbleed Revisited: Is it just a Buffer Over-Read -HEARTBLEED ANALYSISA vulnerability can be described precisely as a sequence of improper states of software execution phases. An improper state is represented by an (operation, operand1, operandn) tuple, where at least one element is improper. The error from the last state is the exploitable one. In some cases, more than one vulnerability may need to be present for an exploit to be harmful."
Heartbleed Revisited: Is it just a Buffer Over-Read -HEARTBLEED ANALYSISThe buggy OpenSSL Heartbeat [10] C code that caused Heartbleed and wreaked havoc across theworld was both in the d1_both.c and t1_lib.c files.
"Heartbleed Revisited: Is it just a Buffer Over-Read -HEARTBLEED ANALYSISThe very first problem is in the data verification phase, where the semantics of the input should bechecked and corrected. The variable payload is declared as an unsigned integer and can be a hugenumber. It is input data, that hold the payload length, but that length is not checked towards an upper limit. Its value is not verified! This improper state is an instance of the BF Data Verification (DVR) class, represented by the (Verify, Data) tuple, where the first element is improper. The operation Verify is missing."
"Heartbleed Revisited: Is it just a Buffer Over-Read -HEARTBLEED ANALYSISThen, memcpy reads payload number of bytes from the object pointed by pl and copies them tothe object pointed by bp. Following the naive C implementation of memcpy in Analysis of Heartbleed, bp and pl are passed by reference via dst and src, and the huge payload length is passed via the argument n. First, one byte is read from pl and copied to bp; then, until the huge payload length is reached, both pointers move one byte up, and the newly pointed by pl byte is read and copied. However, while bp is allocated large enough, pl points to an array with reasonable size. As the content of this array is read and copied to bp, so, too, is a huge amount of data from over its bounds."
"Heartbleed Revisited: Is it just a Buffer Over-Read -HEARTBLEED ANALYSISThere are two improper states here: when pl gets repositioned over its upper bound, and when data areread from there. The former is an instance of the BF Memory Addressing (MAD) class, representedby the (Reposition, Data,Type, Address, Size) tuple, where the second element is improper. There is no bug in the repositioning itself, however, a value that is inconsistent with the size of the pl object is used. The latter is an instance of the BF Memory Use (MUS) class, represented by the (Read, Data, Type, Address, Size) tuple, where the fourth element is improper. Again, there is no bug in the Read operation itself, but, because pl points over bounds, the software reads data that should not be read as known as buffer over-read."
"Heartbleed Revisited: Is it just a Buffer Over-Read -HEARTBLEED ANALYSISThis chain of three BF states shows there is read over the buffer bounds, however, it does not show how an exploit could reach sensitive data, such as private keys. The vulnerability triggered by the missing size verification bug is not enough to get access to sensitive information."
"Heartbleed Revisited: Is it just a Buffer Over-Read -HEARTBLEED ANALYSISTo describe the bug in this parallel vulnerability, we use again the BF MUS class. The improper state is represented by the (Clear, Data, Type, Address, Size) tuple, where the first element is improper, butthis time the operation Clear is missing. Converging the final errors from both chains - buffer over-read and not cleared object - the buggy software can now reach and expose sensitive information."
"Heartbleed Revisited: Is it just a Buffer Over-Read -HEARTBLEED ANALYSISThe fix of the bug in the main Heartbleed chain is as trivial as the bug itself. An input data value check is added, so that, if the requested and the actual lengths (sizes) are different, the heartbeat message is silently ignored."
"Heartbleed Revisited: Is it just a Buffer Over-Read -HEARTBLEED ANALYSISOur code analysis reveals the causal relationships between the weaknesses underlying Heartbleed. Missing input data verification leads to use of inconsistent size for a buffer, allowing a pointer reposition over bounds, which converging with missing clear, allows remote reads of sensitive information and its exposure."
"Heartbleed Revisited: Is it just a Buffer Over-Read -BF DESCRIPTION OF HEARTBLEEDA BF vulnerability description uses causal relations to form a chain of underlying weaknesses,leading to a failure. Each weakness is an instance of a weakness type with a particular bug or faultas a cause and an error as a consequence. It is represented by a (bug, operation, error) or (fault, operation, error) triple, which elements adhere to the BF class taxonomies. The error is the result of an operation over its operands. It establishes the transition to another weakness or a failure. A BF vulnerability description also uses attributes to explain what, how, and where went wrong.They help us understand the severity of the bug or the fault causing the weakness."
"Heartbleed Revisited: Is it just a Buffer Over-Read -BF DESCRIPTION OF HEARTBLEEDOur precise BF description of Heartbleed is depicted in BF description of Heartbleed (CVE-2014-0160) (machine readable versions are accessible from the BF website). Using the BF taxonomy of the involved weaknesses, first is the Data Verification (DVR) weakness, represented by the (Missing Code, Verify, Inconsistent Value) cause-operation-consequence triple. The missing input data verification (semantics check) code defect bug leads to a data error - a data value that is inconsistent with (not corresponding to) the size of the buffer. The Mechanism, Source Code, and Execution Space attributes are about the Verify operation. The Data State attribute is about the Data operand. Mechanism shows the missing verification should have been check against size (length). Source Code shows the buggy code is in codebase - the d1_both.c and t1_lib.c source files. Execution Space shows with what privilege level the buggy code is running - it is in an environment with local user (limited) permissions. Data State shows where the data come from - they are transferred via a network."
"Heartbleed Revisited: Is it just a Buffer Over-Read -BF DESCRIPTION OF HEARTBLEEDNext is the Memory Addressing (MAD) weakness, represented by the (Wrong Size, Reposition, Over Bounds Pointer) causeoperation-consequence triple. The wrong size data fault at repositioning leads to a pointer pointing overbounds address error. The Mechanism attribute here shows how the repositioning is done - it is sequential, iterating over the buffer elements. The Address State attribute shows where the buffer is laid out - it is dynamically allocated in the heap. The Size Kind attribute shows what the limit for iteration over object's elements is - it is a requested value."
"Heartbleed Revisited: Is it just a Buffer Over-Read -BF DESCRIPTION OF HEARTBLEEDLast in this chain is the Memory Use (MUS) weakness, represented by the (Over Bounds Pointer, Read, Buffer Over-Read) causeoperation-consequence triple. The over bounds pointer address fault results in a buffer over-read memory disclosure final error4. The Address Kind attribute shows what the accessed outside object's bounds memory (up to 64KB of memory)."
"Heartbleed Revisited: Is it just a Buffer Over-Read -BF DESCRIPTION OF HEARTBLEEDComing from another chain is again a MUS weakness, represented by the (Missing Code, Clear, Not Cleared Object) cause-operationconsequence triple. The missing clear (change to non-meaningful value -for example via zeroization) code defect bug leads to an object with not cleared data memory disclosure final error (see the one-group chain in Figure 4). The attributes are the same as for the MUS weakness in the first chain, however, this is a different vulnerability and the source code is in different software."
"Heartbleed Revisited: Is it just a Buffer Over-Read -BF DESCRIPTION OF HEARTBLEEDThe memory disclosure final errors buffer over-read and not cleared object, combined, cause informationexposure (IEX) security failure. Either the missing verification bug or the missing clear bug has to be fixed to avoid this security failure."
"Heartbleed Revisited: Is it just a Buffer Over-Read -DISCUSSIONThe OpenSSL cryptographic software library is used by Internet servers - including Hypertext Transfer Protocol Secure (HTTPS) websites - to secure network communications against eavesdropping or to identify communicating parties. It is widely popular and deployed on servers worldwide. However, it is still software and may have bugs, leading to security vulnerabilities."
"Heartbleed Revisited: Is it just a Buffer Over-Read -DISCUSSIONHeartbleed was introduced in the OpenSSL TLS Heartbeat Extension in 2012 and when discoveredin 2014 was already on hundreds of thousands of web servers. It was so severe that for increased awareness became the first vulnerability with its own logo and name, and catalyzed formal methods researchtowards security vulnerabilities."
"Heartbleed Revisited: Is it just a Buffer Over-Read -DISCUSSIONOnce identified, the bug in the TLS implementation of the Heartbeat Extension was easy to fix anda patch for the OpenSSL cryptographic software library was distributed. Nevertheless, in 2019 - five years later - the Heartbleed vulnerability was still present on 77K devices worldwide, including over 18K Apache httpd servers. In 2020, attacks against Heartbleed were still ongoing and there might still be thousands of unpatched, and thus vulnerable to Heartbleed systems, that we are accessing unaware of the risks."
"Heartbleed Revisited: Is it just a Buffer Over-Read -DISCUSSIONThe most frequent memory corruption exploits relate to buffer overflow (for example buffer over-write), which is also second to injection in severity. However, as demonstrated by Heartbleed, buffer over-read although not so frequent can also be very dangerous, as exposure of sensitive information is at stake. It is key to acknowledge though that there would be no information exposure failure if sensitive data were alwaysprotected or at least always cleared from memory after being used."
"Heartbleed Revisited: Is it just a Buffer Over-Read -DISCUSSIONDevelopers of applications could prevent the damage from buffer over-reads if they understood clearlyhow the failure emerges. As we point, there are two contributing chains of weaknesses and the informationexposure failure can be prevented by fixing the bug in only one of these chains. The Heartbleed vulnerability bug from the first chain would not cause any harm if the missing clear bug of thesecond chain is not present or fixed. If unused sensitive data are always promptly removed from memory, evena severe vulnerability such as Heartbleed would be much harder to exploit."
"Heartbleed Revisited: Is it just a Buffer Over-Read -DISCUSSIONOne may argue that the Heartbleed vulnerability could be used to expose sensitive data while they arein use. For example, an ingenious attacker could hit the SSL/TLS certificate private key when it is in the system memory and being used. Even though this attack is extremely hard, clarifying that BF descriptions are context-sensitive is crucial."
"Heartbleed Revisited: Is it just a Buffer Over-Read -DISCUSSIONThe context of other software or hardware, interacting with the vulnerable software, may inflict modifications in the detailed BF description of a particular vulnerability. The provided in this article description of Heartbleed considers only the OpenSSL Heartbeat Extension and the sensitive data left in memory by other software. For example, no trusted execution environment (TEE) is taken into consideration."
"Heartbleed Revisited: Is it just a Buffer Over-Read -DISCUSSIONIn the context of strong memory access control (such as hardware-based protection), the second chain of the BF Heartbleed description would be different. We would use the BF Authentication (ATN) class to describe Heartbleed for a server where private keys could be protected by a TEE but they are not, allowing an attacker to use Heartbleed to reach these keys outside the secure memory."
"Heartbleed Revisited: Is it just a Buffer Over-Read -DISCUSSIONAll this brings us to the realization that more context aware efforts and research are needed towards understandable and formalizable vulnerability descriptions. The former - to assure clear communication aboutbugs, weaknesses, and vulnerabilities among Information Technology (IT) executives and professionals.The latter - to empower development of tools for vulnerability detection, prediction, and prevention. Theprecise detailed description of Heartbleed in this article is a demonstration of our efforts towards these goals"
"Heartbleed Revisited: Is it just a Buffer Over-Read -CONCLUSIONSoftware security vulnerabilities open the door for attacks towards Cyberspace and the critical infrastructure. Heartbleed was one of the most severe and damaging vulnerabilities in the Web history. Because the OpenSSL cryptographic software library is used for secure communication over SSL/TLS and Datagram Transport Layer Security (DTLS), the easy Heartbleed exploits can reveal highly sensitive information, such as private keys, login credentials, and business or personal information from all over the Internet."
"Heartbleed Revisited: Is it just a Buffer Over-Read -CONCLUSIONIn this article, we identify and clearly describe the two chains of weaknesses that underlie Heartbleed and that converge to cause the information exposure failure regularly blamed only on buffer overread. We explain the causal relations between the improper states in the buggy C code. Then we detail the (bug, operation, error) or (fault, operation, error) triples for each involved weakness. Finally, we provide the full BF description of Heartbleed, clearly showing the bugs starting the two chains, of which at least one must be fixed to avoid the information exposure security failure."
"Heartbleed Revisited: Is it just a Buffer Over-Read -CONCLUSIONThe OpenSSL team fixed the main bug and distributed the patch almost immediately after Heartbleedwas disclosed in April 2014. However, even now - nine years later - we have no guarantee sensitiveinformation would not be exposed from the system memory of a server (or a client) running a vulnerable version of OpenSSL."
"Heartbleed Revisited: Is it just a Buffer Over-Read -CONCLUSIONAs demonstrated by Heartbleed, information exposure failure could be reached by exploiting a vulnerability that enables remote access to uncleared objects with sensitive data. Given the intricacy of softwarestacks in real-world applications, it is improbable such vulnerabilities to be entirely eradicated. Therefore, we urge software developers to promptly clean memory from unused - and especially unencrypted - sensitive data."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- AbstractIn this work, we present an orthogonal classification of input/output check bugs, allowing precise structured descriptions of related software vulnerabilities. We utilizethe Bugs Framework (BF) approach to define two languageindependent classes that cover all possible kinds of data check bugs. We also identify all types of injection errors, as they arealways directly caused by input/output data validation bugs.In BF each class is a taxonomic category of a weakness typedefined by sets of operations, cause/consequence relations,and attributes. A BF description of a bug or a weakness isan instance of a taxonomic BF class with one operation, onecause, one consequence, and their attributes. Any vulnerabilitythen can be described as a chain of such instances and theirconsequence-cause transitions. With our newly developed DataValidation Bugs and Data Verification Bugs classes, we confirmthat BF is a classification system that extends the CommonWeakness Enumeration (CWE). It allows clear communicationabout software bugs and weaknesses, providing a structuredway to precisely describe real-world vulnerabilities.Keywords-Bug classification, bug taxonomy, software vulnerability, software weakness, input validation, input sanitization, input verification, injection."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- I. INTRODUCTIONThe most dangerous software errors that open the doorsfor cyberattacks are injection and buffer overflow. Injection is directlycaused by improper input/output data validation. Bufferoverflow may be a consequence of improper input/output dataverification. Classifying all input/output data check bugsand defining the types of injection errors would allow precisecommunication and help us teach about them, understand andidentify them, and avoid related security failures."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- I. INTRODUCTIONThe Common Weakness Enumeration (CWE) and theCommon Vulnerabilities and Exposures (CVE) are wellknown and used lists of software security weaknesses and vulnerabilities. However, they have problems. CWE's exhaustive list approach leads to gaps and overlaps in coverage, as demonstrated by the National Vulnerability Database (NVD)effort to link CVEs to appropriate CWEs . Many CWEsand CVEs have imprecise and unstructured descriptions. Forexample, CWE-502 is imprecise as it is not clear what""sufficiently"" and ""verifying that data is valid"" mean. Dueto the unstructured description of CVE-2018-5907, NVD has changed the assigned CWEs over time, and currently maps CWE-190, while the cause is CWE-20 and the full chainis CWE-20-CWE-190-CWE-119 - lack of input verificationleads to integer overflow and then to buffer overflow."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- I. INTRODUCTIONThe Bugs Framework (BF) builds on these commonly used lists of software weaknesses and vulnerabilities,while addressing the problems that they have. It is being developed as a structured, complete, orthogonal, and languageindependent classification of software bugs and weaknesses.Structured means a weakness is described via one cause,one operation, one consequence, and one value per attributefrom the lists defining a BF class. This ensures precisecausal descriptions. Complete means BF has the expressiveness power to describe any software bug or weakness. This ensures there are no gaps in coverage. Orthogonal means thesets of operations of any two BF classes do not overlap.This ensures there are no overlaps in coverage. BF is alsoapplicable for source code in any programming language.The cause/consequence relation is a key aspect of BF'smethodology that sets it apart from any other efforts. Itallows describing and chaining the bug and the weaknessesunderlining a vulnerability, as well as identifying a bug froma final error and what is required to fix the bug."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- I. INTRODUCTIONWe utilize the BF approach to define two languageindependent, orthogonal classes that cover all possible kindsof data check bugs and weaknesses: Data Validation Bugs(DVL) and Data Verification Bugs (DVR). The BF DataCheck Bugs taxonomy can be viewed as a structured extension to the input, output, and injection-related CWEs, allowing bug reporting tools to produce more detailed, precise,and unambiguous descriptions of identified data validationand data verification bugs."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- I. INTRODUCTIONThe main contributions of this work are: i) we create amodel of data check bugs; ii) we create a taxonomy that hasthe expressiveness power to clearly describe any data checkbugs or weaknesses; iii) we confirm our taxonomy covers thecorresponding input/output CWEs; iv) we showcase the useof our input/output check bugs taxonomy.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- I. INTRODUCTIONWe achieve these contributions respectfully via: i) identifying the operations, where data validation and data verification bugs could happen; ii) developing two new structured,orthogonal BF classes: DVL and DVR, while also definingfive types of injection errors; iii) generating digraphs ofCWEs related to input/output validation weaknesses, as wellas to injection errors, and mapping these CWEs to BF DVLand BF DRV by operation and by consequence; iv) describingreal-world vulnerabilities using BF DVL and BF DVR: CVE2020-5902 BIG-IP F5, CVE-2019-10748 Sequelize SQL Injection, and the DVR bug in CVE-2014-0160 Heartbleed."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- I. INTRODUCTIONThe rest of the paper is organized as follows: InSection II, we recall BF's approach and methodology. InSection III, we analyze the types of data check bugs anddefine the BF Data Check Bugs model. In Section IV, wepresent our new BF DVL and BF DVR classes. In Section V,we analyze the correspondence of the input, output, andinjection-related CWEs to the new BF classes. In Section VI,we use the BF Data Check Bugs taxonomy to provide better,structured descriptions of real-world vulnerabilities. Finally, in Section VII we discuss related worksand in Section VIII we summarize the paper contributionsand we propose future works."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- II. BF APPROACH AND METHODOLOGY BF describes a bug or a weakness as an improper stateand its transition. The transition is to another weaknessor to a failure. An improper state is defined by the tuple(operation, operand1,..., operandn) where at leastone element is improper. The initial state is always caused bya bug - a coding error within the operation, which, if fixed,will resolve the vulnerability. An intermediate state is causedby ill-formed data; it has at least one improper operand. Thefinal state, the failure, is caused by a final error (undefinedor exploitable system behavior) that usually directly relatesto a CWE. A transition is the result of the operation over theoperands."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- II. BF APPROACH AND METHODOLOGY BF describes a vulnerability as a chain of improperstates and their transitions. Each improper state is an instanceof a BF class. The transition from the initial state is byimproper operation over proper operands. The transitionsfrom intermediate states are by proper operations with at leastone improper operand.
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- II. BF APPROACH AND METHODOLOGY Operations or operands improperness defines the causes.A consequence is the result of an operation over its operands.It becomes a final error or the cause for a next weakness.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- II. BF APPROACH AND METHODOLOGY A BF class is a taxonomic category of a weakness type,defined by a set of operations, all valid cause?consequencerelations, and a set of attributes. The taxonomy of a particularbug or weakness is based on one BF class. Its description isan instance of a taxonomic BF class with one cause, oneoperation, one consequence, and their attributes. The operation binds the cause/consequence relation - e.g., underrestrictive sanitization policy leads to a final error known asSQL (Structured Query Language) injection."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- II. BF APPROACH AND METHODOLOGY CWEs coverage by any newly developed BF classescan be visualized via digraphs, based on CWEs parentchild relationships. Once analyzed, these digraphs can help understand CWEs structure and how they translate to BF."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- II. BF APPROACH AND METHODOLOGY The taxonomies of newly developed BF classes canbe demonstrated by providing structured BF descriptions ofappropriate CVEs.
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- II. BF APPROACH AND METHODOLOGY The methodology for developing a BF class comprisesidentifying/defining: (1) the phase specific for a kind of bugs;(2) the operations for that phase; (3) the BF Bugs modelwith operations flow; (4) all causes; (5) all consequences thatpropagate as a cause to a next weakness; (6) all consequences that are final errors; (7) attributes useful to describe such a bug/weakness; (8) the possible sites in code; (9) CWEdigraphs by class and consequence; (10) CVE test cases.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- II. BF APPROACH AND METHODOLOGY Data should be checked to ensure proper results from itsprocessing. It should adhere to object data types acceptable bythe software. In a paper with title ""Classifying Memory Bugs UsingBugs Framework Approach written by Bojanova and Galhardo, define an objectas a piece of memory with well-defined size that is used tostore primitive data or a data structure. As input, primitivedata are checked and sanitized on string-of-characters level.A character - e.g., an ASCII (American Standard Code forInformation Interchange) character - is a single symbol, suchas an alphabet letter, a numeric digit, or a punctuation mark.Data structures in turn are built on primitive data but can alsohave a higher level of syntax and semantics rules."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- III. DATA CHECK BUGS MODELData check comprises data validation, where data syntaxgets checked for being well-formed, and data verification,where data semantics gets verified for being accurate. TheBF model separates data semantics check as data verification,although OWASP (Open Web Application Security Project)puts it under input validation."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- III. DATA CHECK BUGS MODELValidation is about accepting or rejecting data basedon its syntax: it checks if data are in proper format (grammar). For example, checking if data consist of digits only or checking the syntax of an XML (Extensible MarkupLanguage) document against a DTD (XML Document TypeDefinition) is data validation. Once data syntax is checked itmay be sanitized. Sanitization is about neutralizing, filtering,or repairing data via escaping, removing, or adding symbolsin data, correspondingly. An example of data sanitizationwould be removing a special character such as '/' or addinga closing parenthesis ')'. The validate and sanitize operations use specific policies, such as to check against safelist,denylist, format (e.g., defined via regular expressions), orlength. A safelist defines a set of known good content. Adenylist defines a set of known bad content; it helps rejectoutright maliciously malformed data. Regular expressionsdefine format patterns that data (viewed as strings) shouldmatch. They could be used for safelists and denylists."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- III. DATA CHECK BUGS MODELVerification is about accepting or rejecting data based onits semantics: it checks if data have proper value (meaning).For example, checking if a start date is before an end date, orchecking the type of an XML document against a PowerPointXSD (XML Schema Definition) is data verification. Oncedata semantics is checked, it may be corrected via assigninga new value or via removing data. An example of datacorrection would be setting the size to the buffer's upperbound when the size that is supplied is larger than that upperbound. The verify and correct operations use specific policiesto, for example, check data against a value (incl. NULL orlist of values), quantity, range, type, or other business rules."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- III. DATA CHECK BUGS MODELData check bugs could be introduced at any of the datavalidation and data verification phases. Each bug or weaknessinvolves one data check operation: validate, sanitize, verify,or correct. Each operation is over already-canonicalized1 dataand the policy (the rules) against which it gets checked."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- III. DATA CHECK BUGS MODELThe BF Data Check Bugs model helped usidentify the phases and the operations where such bugs couldoccur. The phases correspond to the BF Data Check Bugsclasses: Data Validation Bugs (DVL) and Data VerificationBugs (DVR). All data check operations are grouped by phase.The operations under DVL are on checking data syntax: Validate and Sanitize. The operations under DVRare on checking data semantics: Verify and Correct. Data could bevalidated and verified or only directly verified. The presented operations flow helps in identifying possible chains of bugs/weaknesses.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESWe define the BF Data Check Bugs classes as follows:-Data Validation Bugs (DVL):Data are validated (syntaxcheck) or sanitized (escape, filter, repair) improperly.-Data Verification Bugs (DVR): Data are verified (semantics check) or corrected (assign value, remove) improperly."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESA. OperationsAll BF classes are being designed to be orthogonal;their sets of operations should not overlap. The operationsin which data check bugs could happen correspond to theoperations in the BF Data Check Bugs model. The DVL operationsare Validate and Sanitize. They reflect the improper check andmodification of data syntax. The DVR operations are Verifyand Correct. They reflect the improper check and modificationof data semantics.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESB. CausesA cause is either an improper operation or an improperoperand. If a BF class instance is the first in a chaindescribing a vulnerability, it is always caused by an improperoperation. The values for improper data check operationsare Missing, Erroneous, Under-Restrictive Policy, and OverRestrictive Policy. "
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESB. CausesThe operands of a data check operation are data andpolicy. An improper operand isdata or policy that has been modified by an operation of aprevious weakness, such as decode, decrypt, and convert."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESB. CausesAll values for an improper operand of a data checkoperation are defined in Table IV. Improper Policy as datafrom a previous weakness is a possible cause only for DVL.Improper Data could be of a primitive data type (e.g., a string,a number) or a data structure. Comments could be used toprovide more details such as data type and variable name."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE I: Operations(a) DVL (Data Validation) has two operations.The first one is Validate defined by Checking data syntax (proper form/grammar) in order to accept (and possibly sanitize) or reject it. Includes checking for missing symbols/elements.The second one is sanitize defined by Modifying data (neutralize/escape, filter/remove, repair/add symbols) in order to make it valid (well-formed).(b) DVR (Data Verification) has two operations. The first one is Verify which can be defined by checking data semantics (proper value/meaning) in order to accept (and possibly correct) or reject it.The second one is Correct which can be defined by modifying data (assign new value, remove), in order to make it accurate."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE II: Improper OperationsThe values for improper data check operations are four.The first value is Missing which means that the operation is absent(for example Missing data sanitization). The second value is Erroneous which means that there's a bug in the operation implementation (incl. how it checksagainst a policy) for instance Using greater than (>) when checking for upper range or Using not equal to (!=) when comparing to safelist values. The third value is Under-Restrictive Policy which means that accepts bad data for instance Permissive safelist or regular expression or Incomplete denylist. The fourth value Over-Restrictive Policy which means that rejects good idea for instance Over-restrictive denylist or regular expression.
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESC. ConsequencesA consequence is either a final error or a wrong resultfrom the operation that propagates as an improper operandfor a next weakness.
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESC. ConsequencesImproper validation or sanitization may directly lead tofinal injection errors. Any other improper data check in anyof the phases would lead to improper data for anoperation in a next weakness.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESC. ConsequencesImproper Data is the only possible improper operand asa consequence from DVL or DVR. All its possible valuesare defined in Table V. As a consequence, improper datawould become a cause for an operation of a next weakness.These consequence-cause transitions explain why InvalidData appears in both Table IV and Table V."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESC. ConsequencesThe only kind of DVR consequences (Table Vb) isimproper operand for next weakness. This means a DVR bugor weakness is always followed by another weakness or achain of weaknesses leading to a final error such as bufferoverflow or memory overflow.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESC. ConsequencesAll DVL final errors are injection errors. We also identifyand define in Table VI five types of injection errors: query injection, command injection, source code injection, parameterinjection, and file injection. All of them, except some source code injections, are due to data with missing, additional, or inconsistent special elements (symbols that can be interpretedas control elements or syntactic markers). The BF modelseparates query injection and command injection from sourcecode injection, although they are commonly discussed underthe umbrella term ""code injection"" . All the possible types of data check errors that end in failureright after the current bug/weakness (as an instance of a BFclass) are DVL final errors, representing the types of injectionerrors."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE III: OperandsThe operands of a data check operation are data and policy. The data can by defined by a string of characters (symbols like letter, digit, punctuation) with clearly defined syntax and semantics. The policy can be defined by Lists or rules for checking data syntax and semantics. For example, safelist, denylist, format (e.g., DTD-XML Document Type Definition), and length; or value (incl. NULL or list ofvalues), quantity, range, and type (e.g., a PowerPoint XSD)."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE IV: Improper Operands - as DVL/DVR Causes(a) Improper Data (from previous operation) - as DVL Cause have two values which are Corrupted Data and Tampered Data. The Corrupted Data can be defined by Unintentionally modified data due to a previous weakness(e.g., with a decompress or a decrypt operation) that if notsanitized would end-up as invalid data for next weakness. The Tampered Data can be defined by Maliciously modified data due to a previous weakness (e.g., with a deserialize, authorize, or crypto verify operation) thatwould lead to injection error."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE IV: Improper Operands - as DVL/DVR Causes(b) Improper Data (from previous operation) - as DVR Cause have one value which is Invalid Data. The Invalid Data are Data with harmed syntax due to sanitization errors.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE IV: Improper Operands - as DVL/DVR Causes(c) Improper Policy (from previous operation) - as DVL Cause have two values.The first value is CorruptedPolicy which means Unintentionally modified policy due to a previous weakness (e.g., with a decompress operation).The second value is Tampered Policy which means Maliciously modified policy due to a previous weakness (e.g., with an authorize operation)."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE V: Improper Operands - as DVL/DVR Consequences(a) Improper Data for Next Operation - as DVL/DVR Consequence have one value which is Invalid Data.The Invalid Data are Data with harmed syntax due to sanitization errors.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE V: Improper Operands - as DVL/DVR Consequences(b) Improper Data for Next Operation - as DVR Consequence have three values. The first value is Wrong value which means that there are Data with harmed semantics; not accurate value (e.g. outside of a range). The second value is Inconsistent Value which means that Data value is inconsistent with the value of a related data (e.g., inconstancy between the value of a size variable and the actual buffer size). The third value is Wrong Type which means that there is Data with wrong data type."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESD. AttributesAn attribute provides additional useful information aboutthe operation or its operands. All possible attributes for datacheck bugs are defined in Table VII. The operation attributesSource Code and Execution Space explain where a bug isor where the operation is in the program and where its coderuns. The data attribute State explains where the data comefrom. See definitions of these attributes' values in Table VIIa.
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESD. AttributesBoth DVL and DVR also have the operation attributeMechanism but with different possible values that are specific to the policies the operations could use to check data. See definitions of this attribute values in Table VIIb and Table VIIc.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VI: Injection Errors - as DVL ConsequencesAll DVL final errors are injection errors. We also identify and define in this Table the five types of injection errors: query injection, command injection, source code injection, parameterinjection, and file injection."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VI: Injection Errors - as DVL ConsequencesThe value Query Injection is defined by Malicious insertion ofcondition parts (e.g. or 1==1) or entire commands (e.g., drop table) into an input used to construct a database query. Some  query injections for example are SQL Injection, No SQL Injection, XPath Injection, XQuery Injection,LDAP Injection."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VI: Injection Errors - as DVL ConsequencesThe value Command Injection is defined by Malicious insertion of new commands into the input to a command that is sent to an operating system (OS) or to a server. Some Command Injections for example are OS Command Injection, Regular Expression Injection,IMAP/SMTP CommandInjection,Object Injection (JSON server side)."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VI: Injection Errors - as DVL ConsequencesThe value Source Code Injection is defined by Malicious insertion of new code (incl. with <> elements) into input used as part of an executing application code. Some Source Code Injection examples are Cross Site Scripting (XSS), CSS Injection, Eval Injection, EL Injection,JSON Injection (Client or Server Side)."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VI: Injection Errors - as DVL ConsequencesThe value Parameter Injection is defined by Malicious insertion of data (e.g., with & parameter separator) into input used as parameter/argument in other parts of code. Some Parameter Injection examples are Argument Injection, Format String Injection, Email Injection, HTTP Header Injection (including Server Header Injection),  Reflection Injection, Flash Injection, CRLF Injection (incl. HTTPHeader Splitting)."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VI: Injection Errors - as DVL ConsequencesThe value File Injection is defined by Malicious insertion of data (e.g. with .. and / or with file entries) into input used to access/modify files or as file content. Some File Injection examples are CSV, Temp, Log Entry Injection, XML Injection, CRLF Injection (incl. in as inlog entry files), Relative Path Traversal, Absolute Path Traversal."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESE. SitesA site for input/output check bugs is any part of the code that should check and sanitize data syntax or check and correct data semantics.
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VII: Attributes(a) DVL and DVR AttributesThe operation attributes Source Code and Execution Space explain where a bug is and where the operation is in the program and where its code runs.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VII: Attributes(a) DVL and DVR AttributesThe operation attribute called Source Code have four values. The first value is Codebase which is defined by the operation is in the programmer's code - in the application itself.The second value is Third Party which is defined by the operation is in a third-party library. The third is Standard Library which is defined by The operation is in the standard library for a particular programming language. The fourth value is Language Processor which is defined by the operation is in the tool that allows execution or creates executables (compiler, assembler, interpreter)."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VII: Attributes(a) DVL and DVR AttributesThe operation attribute called Execution Space have three values. The first value called Local is defined by the bugged code runs in an environment with access control policy with limited (local user)permission. The second value called Admin is the bugged code runs in an environment withaccess control policy with unlimited (admin user) permission. The third value called Bare-Metal is the bugged code runs in an environment without privilege control. Usually, the program is theonly software running and has total access to the hardware."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VII: Attributes(a) DVL and DVR AttributesThe data attribute called State explains where the data come from. The state has four values.The first value called Entered is Data when comes from user interface (e.g. text field). The second value called Stored is Data when comes from permanent storage (e.g. file, database on a storage device). The third value called In Use is Data when comes from volatile storage (e.g., RAM, cache memory). The fourth value called Transferred is Data when comes via network (e.g., connecting analog device or another computer)."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VII: Attributes(b) DVL AttributeBoth DVL and DVR also have the operation attribute Mechanism but with different possible values that are specific to the policies the operations could use to check data.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VII: Attributes(b) DVL AttributeDVL have the operation attribute Mechanism with four values. The first value is Safelist which is the Policy based on a set of known good content. The second value is Denylist which is the Policy based on a set of known bad content; helps reject outright maliciously malformed data. The third value is Format which is the Policy based on syntax format (e.g., defined via regular expression). The fourth value is Length which is the Policy based on allowed number of characters in data. Note that this is not about the data value as size of an object."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- IV. BF DATA CHECK BUGS CLASSESTABLE VII: Attributes(b) DVR AttributeDVR have the operation attribute Mechanism with five values. The first value called Value is defined by Checking data for a specific value (incl. NULL or list of values). The second value called Quantity is defined by Checking data for a specific measurable value (e.g., size, time, rate, frequency). The third value called Range is defined by Checking data are within a (min, max) interval. The fourth value called Type is defined by Checking data type (e.g., int, float, XSD-XML Schema Definition, or specific structure/object). The fifth value called Other rules is defined by Checking data against other business logic."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONIn this section, we analyze the correspondence of theinput, output, and injection-related CWEs  to the two newBF DVL and DVR classes. We show that the BF classescover all related CWEs, and potentially beyond, while (asdemonstrated later in Section VI) providing a better structuredway for describing these kinds of bugs/weaknesses"
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONThe BF classes ensure precise causal descriptions, as aweakness is described via one cause, one operation, and oneconsequence, while the CWEs only enumerate weaknesses.The CWEs exhaustive list approach is prone to gaps incoverage: some weakness types may be missing. The CWEsalso have overlaps in coverage, including via over detailing(e.g., CWE-23 children's path traversal variations). While bytheir nature, the BF classes are complete and orthogonal,assuring no gaps and no overlaps in coverage. We map a CWE to a BF class by an operation and/or a consequence from the lists defining the BF class. Through these relationships,the BF classes can be viewed as structured extensions to theinput, output, and injection-related CWEs."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONThe BF Data Check Bugs classes relate to particularCWEs by BF DVL and DVR operations and/or consequences.We generated a digraph of all input- and output-check-relatedCWEs, including the injection-related CWEs, to show thiscorrespondence both by operation and by consequence. In the digraph, an edge starts at a parent CWE and ends at a child CWE. The outline style of a CWE node indicates the CWE level of abstraction: pillar, class,base, or variant."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONAlmost all of the 162 CWEs, visualized on the digraph, can be tracked as descendants of the pillar CWE-707; exceptions are CWEs 15, 73 (its child 114), 98, 134, 183, 184, 185 (and its children 186 and 625), 428, 472, 565, and 913."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONAnalyzing the digraph, we see that the pillar CWE707 reflects neutralization of malformed messages; it is quite broad. It is the parent of several CWEs that are not strictlyinput/output check related."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONThe digraph helped us identify seven distinct clusters ofCWEs with parent CWEs 20, 22, 41, 74, 116, 138, and 228."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONThe outline color of a CWE node indicates theBF class(es) and operation(s) associated with that CWE: DVLValidate, DVL Sanitize, DVR Verify, and DVL Validate andDVR Verify. There are no CWEs that relate to DVR Correct.The CWE-20 cluster is the only one that corresponds to DVRVerify. However, some of its descendants correspond also toDVL Validate. The CWE-41 and CWE-228 (except 3 nodes)clusters correspond to DVL Validate. The rest of the clusters,CWE-22, CWE-74, CWE-116, and CWE-138, correspond toDVL Sanitize."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONThe outline color of a CWE node indicatesthe BF class consequence associated with that CWE: QueryInjection, Command Injection, Source Code Injection, Parameter Injection, File Injection, Invalid Data, Wrong Value, Inconsistent Value, or Wrong Type."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONThe CWE-74 cluster is all about injection; the largestgroup there is Source Code Injection, then are Query Injectionand Command Injection, and a few nodes of File Injectionand Parameter Injection. CWEs 74, 75, 76, 913, 914 arenot colored, as they are about general injection errors. TheCWE-22 and CWE-41 clusters are all about File Injection.The CWE-138 cluster is mostly about Parameter Injectionand some Source Code Injection. Some of the CWE-138nodes correspond to the DVL Invalid Data for Next Operationconsequence. The CWE-20 cluster (which is DVR related)has nodes corresponding to the DVR Wrong Data for NextOperation consequences; however, some of these CWEsdescribe only causes and do not list consequences."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONAll relationships to input, output, and injection CWEs by BF DVL and BF DVR consequences are asfollows:1) The DVL class relates to CWEs through its Wrong Datafor Next Operation consequence as follows:  Invalid Data - CWEs: 138, 153, 155, 158, 159, 160,162, and 164."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONAll relationships to input, output, and injection CWEs by BF DVL and BF DVR consequences are asfollows:2) The DVL class relates to CWEs also through its Injection Error consequences as follows:Query Injection - CWEs: 89, 90, 91, 564, 643, 652,and 943; Command Injection - CWEs: 77, 78, and 624;Source Code Injection - CWEs: 79, 80, 81, 83, 82,85, 86, 87, 94, 95, 96, 97, 98, 149, 692, 917, and1336; Parameter Injection - CWEs: 88, 93, 113, 134, 140,141, 142, 143, 144, 145, 146, 147, 148, 150, 151, 152,154, and 157; File Injection - CWEs: 22, 23, 24, 25, 26, 27, 28, 29,30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,58, 73, 99, 117, 641, and 1236."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONAll relationships to input, output, and injection CWEs by BF DVL and BF DVR consequences are asfollows:3) The DVR class relates to CWEs through its Wrong Datafor Next Operation consequence as follows: Wrong Value - CWEs: 129, 170, 606, 781, 1285, and 1289; Inconsistent Value - CWEs: 130, 230, 232, and 1288; Wrong Type - CWEs: 1284, and 1287."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONAll relationships to input, output, and injection CWEs by BF DVL and BF DVR consequences are asfollows:4) The following CWEs reflect only DVL or DVR causes:102, 105, 106, 108, 109, 183, 184, 185, 186, 228, 229,231, 233, 234, 235, 236, 237, 238, 239, 240, 554, 625,1173, and 1174."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONThe BF Data Check Bugs classes present a taxonomywith structured cause/consequence relations that is completeand orthogonal. It could be viewed as a structured extensionover the CWEs related to Injection Errors, Invalid Data,Wrong Value, Inconsistent Value, and Wrong Type. Itis a taxonomy that explains the causal relationships betweenweaknesses and would be easier to use than the nestedhierarchical CWEs."
" Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- V. BF DATA CHECK BUGS TAXONOMY AS CWE EXTENSIONMany bug reporting tools use the CWE to describe found bugs/weaknesses. As a structured extensionover the input, output, and injection CWEs, the BF DataCheck taxonomy can be used to report found data checkbugs/weaknesses (including those leading to injection errors)."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VI. SHOWCASESIn this section, we use the new BF Data Check Bugsclasses for precise descriptions of real-world software vulnerabilities. We also provide the real-world fixes of each bug."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VI. SHOWCASESA. CVE-2020-5902 - BIG-IP TMUI RCEThis vulnerability is listed in CVE-2020-5902. It wasone of the top routinely exploited vulnerabilities in 2020 .It was identified by Mikhail Klyuchnikov.1) Brief Description: BIG-IP is a family of server-sideproducts from F5 Inc. focused on availability, performance,and security. In several versions, its Traffic ManagementInterface (TMUI), known as the BIG-IP Configuration utility,allows Remote Code Execution (RCE).2) Analysis: TMUI of BIG-IP accepts /..;/ via thelogin interface /tmui/login.jsp. However, the ApacheTomcat treats /..;/ as /../, which is a relative pathfor going one directory up. This allows a malicious user tobypass authentication, save and open files, and run arbitrarycommands on the host..3) The Fix: To fix the bug, input validation (e.g., viathe "".*\.\.;.*"" regular expression) should be added toreject any /..;/ elements."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VI. SHOWCASESB. CVE-2019-10748 - Sequelize SQL InjectionThis vulnerability is listed in CVE-2019-10748. It wasdiscovered by the Snyk Security Team.1) Brief Description: Sequelize is an Object-RelationalMapper for Node.js. It supports Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server; it facilitates transaction support, relations, and lazy loading [19]. In severalversions query-generator.js allows SQL injection.2) Analysis: User input path is not sanitized forMySQL/MariaDB syntax in a JSON (JavaScript Object Notation) object. 3) The Fix: To fix the bug, the developers check theinput paths syntax and sanitize it."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VI. SHOWCASESC. CVE-2014-0160 - Heartbleed Buffer OverflowThis vulnerability is listed in CVE-2014-0160.Heartbleed is using the BF MAD (Memory Addressing Bugs) and the BF MUS (MemoryUse Bugs) classes. Here we complete the BF taxonomy forHeartbleed by describing the DVR bug that starts the chainof weaknesses leading to buffer overflow.1) Brief Description: Heartbleed is a vulnerability dueto a bug in the OpenSSL that allows a server to read over thebounds of a buffer. Using the heartbeat extension tests in TLS(Transport Layer Security) and DTLS (Datagram TransportLayer Security) protocols, a user can send a heartbeat requestto a server. The request contains a string and a payloadunsigned integer, which value is expected to be the stringsize but could be as big as 65535.2) Analysis3) The Fix: To fix the bug, the OpenSSL team added avalue verification for the array size."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VII. RELATED WORKSIn this work, we introduce BF's new classes for datavalidation and data verification bugs. They can be used todescribe input data check bugs that lead to injection errors orto improper (e.g., inconsistent) data that would cause othersoftware errors (e.g., buffer overflow)."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VII. RELATED WORKSSeveral authors attempted to create successful taxonomies of bugs/weaknesses that lead to security failures. Data validation (usually called parameter or input validation) is a commoncategory across the different taxonomies reviewed by them.The new BF Data Check Bugs taxonomy differs from any ofthese taxonomies as it allows describing how a security failureemerges from a bug by a chain of weaknesses. For a bug toexist, there should be a particular cause leading to a particularconsequence. In BF, the kinds of causes relate either toimproper operations or to improper operands. The causeof one weakness could be the consequence of a previousweakness. This chain of weaknesses eventually ends in asoftware error that leads to a security failure. This approachclearly explains, for example, that the well-known Heartbleedvulnerability starts with a Data Verification Bug, which leadsto memory-related weaknesses, ending in a buffer overflowerror. Using any of the reviewed taxonomies, it would notbe possible to describe and understand the interrelationshipbetween weaknesses nor how the failure (e.g., exposure ofsensitive information in Heartbleed) emerges."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VII. RELATED WORKSRay and Ligatti formally define what they callcode injection on output (CIAO). The reasoning behind theirdefinition is that injection errors happen when untrusted inputpropagates unmodified to output. The CIAO definition isequivalent to the union of our definitions of query injection,command injection, and source code injection. All, exceptsome source code injections, are related to unchecked symbols that propagate from input to output."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VII. RELATED WORKSRay and Ligatti also define code interference attackson outputs (CIntAO). The reasoning behind their CAIntOdefinition is analogous to the reasoning for our ParameterInjection definition - maliciously inserted data causes anunexpected behavior that leads to a security failure.
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VII. RELATED WORKSIn some sources/papers, the term ""codeinjection"" is used to describe an RCE failure, caused forexample, by buffer overflow. Although this kind of securityfailure is not caused by source code injection (as we havedefined it), for some buffer overflow errors a data verificationbug may be the first bug in the chain leading to that error(see Section VI-C). Using BF to describe such a vulnerability would help clearly separate source code injection from buffer overflow that leads to arbitrary code execution. This exemplifies how BF can help avoid confusion in vulnerability descriptions and improve communication about bugs, weaknesses, and the security failures caused by them."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VII. RELATED WORKSCurrently, several institutions provide lists of securitybugs/weaknesses. From these, we recognizethe MITRE CWE as the most widely known and used one.We discuss in Section V how BF extends the CWE exhaustivelist approach, as well as how to map CWEs to BF classes andextend the CWE based bug reports with BF descriptions."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VIII. CONCLUSIONIn this paper, we introduce two new BF classes: DataValidation Bugs (DVL) and Data Verification Bugs (DVR).We present their operations, possible causes, consequences,attributes, and sites. We show how they cover all CWEsrelated to input/output validation, verification, as well as toinjection. We analyze particular input data check and injectionvulnerabilities and provide their precise BF descriptions. TheBF structured taxonomies show the initial error in code(the bug), providing a quite concise and still far more cleardescription than the unstructured explanations in currentrepositories, advisories, and publications. The BF Data CheckBugs taxonomy can be used by bug reporting tools, as it isa structured extension over the input, output, and injectionrelated CWEs. To our knowledge there is no other bug taxonomy that allows precise causal descriptions of datavalidation and data verification bugs/weaknesses."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VIII. CONCLUSIONFuture work should identify and describe more CVEs related to data validation and data verification bugs/weaknesses,evaluating the BF Data Check Bugs taxonomy for usability. Insuch an evaluation, a machine learning algorithm or multipleanalysts would classify and describe newly reported bugs, while helping improve BF's taxonomy by fine-tuningthe classes."
"Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VIII. CONCLUSIONThe CWE digraphs by BF class consequences should bedeeply analyzed. Generation of digraphs with CWEs relatedto particular software errors (e.g., injection errors), detectingcorresponding clusters, and understanding their relationshipswould create a comprehensive view of the CWE modelfor researchers and practitioners. In turn, comparing andcontrasting the CWE's exhaustive list of weaknesses with allthe possible consequence-cause transitions to other BF classeswould improve BF as a tool for describing CVEs."
Input/Output Check Bugs Taxonomy: Injection Errors in Spotlight- VIII. CONCLUSIONWe will continue developing orthogonal BF classes thatcover and extend the CWE weakness types.
"Labeling Software Security Vulnerabilities- AbstractLabeling software security vulnerabilities would greatly benefit modernartificial intelligence cybersecurity research. The National Vulnerability Database(NVD) partially achieves this via assignment of Common Weakness Enumeration(CWE) entries to Common Vulnerabilities and Exposures (CVE) entries. In thiswork, we explore utilization of the Bugs Framework (BF) formalism for systematicand comprehensive CVE labeling. We specify all memory-related CWEs via BFweaknesses and examine the suitability of these formalisms to describe thecorresponding CVEs mapped by NVD. We also identify similarities and overlaps inCWEs that introduce ambiguities in NVD assignments"
"Labeling Software Security VulnerabilitiesThere are more than 228000 (as of August 2023) publicly disclosed cybersecurity vulnerabilities in the Common Vulnerabilities and Exposures (CVE) repository - over 25000 documented in 2022 alone. Systematic labeling of this huge set of software security vulnerabilities would enable advances in modern artificial intelligence (AI) cybersecurity research. The current state-of-theart are the National Vulnerability Database (NVD) mappings of CVEs to Common Weakness Enumeration (CWE) entries and assignments of CVE severity scores according to the Common Vulnerability Scoring System (CVSS). However, deeper analysis of the CWE entries shows many are overly specific, ambiguous, or overlapping, complicating the CWE-CVE assignment."
"Labeling Software Security VulnerabilitiesThe Bugs Framework (BF) formalism assures precise descriptions of software security vulnerabilities, which is instrumental in gaining a deeper understanding of the CVEs. The existing NVD mappings,although flawed, offer an opportunity to gain high-level insights into the CVEs through the CWEs. Mappingthe CWEs to BF and then using the NVD CWECVE assignments allows us to take advantage of BF'sformal model in the context of the CVEs. This application of BF can capture the primary concepts (for example recurrent operations, consequences) expressed by the overwhelming number of CVEs and ultimately inform an automated labeling approach based on machine learning (ML). We can learn, for example, that thousands of CVEs relate to erroneous read, while there are none relating to erroneous reallocate. The CWEBF mappings also provide formal BF descriptions that at least partially fit many CVEs, which can aid in theirannotation."
"Labeling Software Security VulnerabilitiesBF's formalism allows us to specify each CWE as a (cause, operation, consequence) BF weakness or a chain of BF weaknesses. These specifications reveal the underlying tacit model of the CWEs and allows us to identify similarities and overlaps in the CWE. The latter are part of the issues that introduceambiguities into the CWEs to CVEs assignments."
"Labeling Software Security VulnerabilitiesThis work is our first exploration of utilizing BFCWE-CVE mappings to specify/label CVEs via BF. Wefocus on the memory-related CWEs, as there are a vast number of memory-related CVEs correspondingto a relatively small number of memory-related CWEs. We specify them via BF weaknesses and examinethe suitability of these formalisms to describe corresponding CVEs. We also discuss identified similaritiesand overlaps among the CWEs, elucidating the NVD's and the security community's struggles with assigningCWEs to CVEs."
"Labeling Software Security Vulnerabilities- Formalizing Memory-Related CWEs via BF Weaknesses or Chains of BF WeaknessesCWE and the BF both classify weaknesses; however, as a formal model, BF has the ability to make thetacit CWE model of memory-related software weaknesses explicit. We employ the BF formal representation of weaknesses as (cause, operation, consequence) triples, the BF vulnerability model, and the BF Memory Bugs taxonomy. Specifically, we use the Memory Corruption/Disclosure (_MEM) BF class type, consisting of three BF classes: the Memory Addressing (MAD) class deals with initialization, repositioning, or reassignment of pointers; the Memory Management (MMN) class deals with erroneous allocation, deallocation, resizing, or reallocation of an object; and the Memory Use (MUS) class deals with the initialization, reading, writing, and clearing an object."
"Labeling Software Security Vulnerabilities- Formalizing Memory-Related CWEs via BF Weaknesses or Chains of BF WeaknessesThe CWEs' web pages mostly consist of textual paragraphs (i.e., the description, extended description,explanations of code snippets, etc.). Many distinct phrases across CWEs have nearly identical meanings,the paragraphs themselves could be interpreted differently, and there is no guarantee a CWE description has all the necessary information to fully understand the corresponding weakness. As an Left-to-right Leftmostderivation One-symbol-lookahead (LL1) grammar, BF inherently lacks ambiguity, and its cause-operationconsequence structure means it is guaranteed to fully describe a software weakness or a vulnerability. Thus, BF can clarify and supplement the CWE entries."
"Labeling Software Security Vulnerabilities- Formalizing Memory-Related CWEs via BF Weaknesses or Chains of BF WeaknessesWe identified 60 memory-related CWEs used for labeling CVEs, starting from the CWE to BF classmappings introduced in ""Classifying Memory Bugs Using Bugs Framework Approach,"". We updated these mappings by BF class operation and created a (cause, operation, consequence)-based BF description for each of these CWEs by deeply analyzing its description, extended description, common consequences, demonstrative code examples, and observed CVE examples."
"Labeling Software Security Vulnerabilities- Formalizing Memory-Related CWEs via BF Weaknesses or Chains of BF WeaknessesIn total, the memory-related CWEs map to 48 distinct BF chains formed by the identified BF (bug, operation, error) and/or (fault, operation, error/final error) weakness triples. Thirty-seven of these BF chains map to a single CWE, and 11 map to more than one CWE. The 60 CWE-BF mappings are depicted across Table 1,Table 2, and Table 3. Table 1 shows CWEs with entirely different BF descriptions. Table 2 and Table 3show CWEs that have similarities in terms of BF. More specifically, Table 2 shows groups of CWEs that havethe same causing chain and Table 3 shows groups of CWEs that have identical BF descriptions. Note thatwe omit the BF Class names when describing the weakness triples, as BF classes are orthogonal byoperation. For example, for CWE-562 (Erroneous Code, Reassign, Wild Pointer) is the sameas (Erroneous Code, MAD Reassign, Wild Pointer)."
"Labeling Software Security Vulnerabilities- Formalizing Memory-Related CWEs via BF Weaknesses or Chains of BF WeaknessesFor CWE-823, CWE-400, and CWE-1325 we were able to identify multiple distinct BF chains . As each CWE entry is supposed to describe only a single weakness, the existence of CWEs that describe multiple distinct weaknesses highlights overlaps within the CWE."
"Labeling Software Security Vulnerabilities- Formalizing Memory-Related CWEs via BF Weaknesses or Chains of BF WeaknessesMany CWEs provide information about preceding weaknesses that we formalize into BF chains ofweaknesses. As a result, some BF specifications contain causing weakness operations from non-memoryrelated BF classes. The first operation is from the Input/OutputCheck (_INP) BF class type and the second two are from the Data Type (_DAT) BF class type. As another example, CWE-126 ostensibly describesa buffer over-read weakness. However, it also describes an erroneous calculation leading to an incorrect pointer reposition. These three weaknesses form the (Erroneous Code, Calculate, Wrong Result) to (Wrong Index, Reposition, Over Bounds Pointer) to (Over Bounds Pointer, Read, Buffer Over-Read) BF chain."
"Labeling Software Security Vulnerabilities- Memory-Related CWEs Similarity and Overlaps via BF SpecificationsThere are three groups of memory-related CWEs (see Table 2) that share one or more of the sameBF weakness triples causing a different BF weakness triple. For example, CWE-127, CWE-786, and CWE124 all begin with (Erroneous Code, Calculate, Wrong Result), which causes (Wrong Index, Reposition, Under Bounds Pointer). This identical causal chain leads to three different main BF weakness triples for CWE-127, CWE-786 and CWE-124, which properly distinguish the three entries."
"Labeling Software Security Vulnerabilities- Memory-Related CWEs Similarity and Overlaps via BF SpecificationsThere are also 11 groups of memory-related CWEs with the same BF weakness or chain ofweaknesses, suggesting areas of repetition or overlap within the CWE."
"Labeling Software Security Vulnerabilities- Memory-Related CWEs Similarity and Overlaps via BF SpecificationsFor example, CWE-401 describes a memory leak due to an allocated object with no references, while CWE-771 describes erroneous removal of all references to an allocated object. However, these weaknesses are quite similar, as the erroneous removal of all references to an allocated object in CWE-771 causes the memory leak described by CWE-401, and the state described by CWE-401 is created by the reassign operations described by CWE-771. In BF terms, these CWE entries are both specified as (Single Owned Address, Reassign, Memory Leak)."
"Labeling Software Security Vulnerabilities- Memory-Related CWEs Similarity and Overlaps via BF SpecificationsOther CWEs have slight differences only by BF attributes, which inform about the severity of theweakness and not about its nature. For example, CWE-121 describes buffer overflow on the stackand CWE-122 describes buffer overflow on the heap. Once the stack versus heap difference isaccounted for by a BF attribute, these two entries are specified by the same instance of a BF weaknesstype: (Over Bounds Pointer/Under Bounds Pointer, Write, Buffer Overflow/Buffer Underflow)."
"Labeling Software Security Vulnerabilities- Memory-Related CWEs Similarity and Overlaps via BF SpecificationsThe CWE hierarchical relationships between CWEs with the same BF chain ), reveal that most of them have either ChildOf or PeerOf relations. Some of them, such as CWEs 121-122-123 and CWEs 170-463-464, are siblings with a common parent. However, there are also instances of CWEs without direct relationships that have identical chains, such as CWE-401 and CWE-771. An interesting observation is that while CWE-123, CWE-415, CWE-416 are specified with very different BF weakness triples, they are listed as peers in the CWE."
"Labeling Software Security Vulnerabilities- Memory-Related CWEs Similarity and Overlaps via BF SpecificationsOf special note are parent-child CWE pairs that share a BF chain. Per the CWE, a parent entry issupposed to be more abstract than its child entry. In BF terms, this is expressed by having multiplepossible causes, consequences, and/or operations (for example Buffer Overflow/Buffer Underflowversus only Buffer Overflow). One would expect that parent/child CWEs would have slightly differentBF chains, or the main weakness for the child would be contained within the main weakness for theparent. For example, (Over Bounds Pointer, Read, Buffer Over-Read) is contained within (Over Bounds Pointer/Under Bounds Pointer, Read, Buffer Over-Read/Buffer Under-Read). The fact that a parent and a child have the same chain (including both an identical main weakness and causing weakness) means this difference in ambiguity is missing and highlights an area of overlap within the CWE."
Labeling Software Security Vulnerabilities- Memory-Related CWEs Similarity and Overlaps via BF SpecificationsBF also reveals missing relationships within the CWE. CWEs that have differences only by BF attributes (for example CWE-121 and CWE-122) should have some relationship (for example PeerOf) within the 
Labeling Software Security Vulnerabilities- Labeling Memory-Related CVEs via BF SpecificationsThere are 60426 memory-related CVEs as of Augustc2023. We queried the CVE repository for entries with CWEs assigned by NVD that map by main operation to the BF Memory Corruption/Disclosure (_MEM) BFclass type. We ordered them by the NVD-assigned CVSS severity scores and selected a maximum of tenCVEs per operation - thus reducing the count to 91 observable CVEs for this exploratory analysis. Thenwe examined the groups of CVEs mapped to CWEs with identical causing BF chains and of CVEs mappedto CWEs with entirely identical BF chains. From the latter group we also identified the CVEs that map toCWEs with parent-child relationships.
"Labeling Software Security Vulnerabilities- Labeling Memory-Related CVEs via BF SpecificationsAnalyzing this subset of CVEs, we find that it covers well the BF memory operations Reposition, Reassign, Verify, Initialize Object, Read, Write, Dereference, Clear, and Deallocate. However, although theremay be CVEs related to the BF memory operations Initialize Pointer, Extend, Reallocate-Extend, Reduce,and Reallocate-Reduce, they are not identifiable via CWEs in the entire CVE repository. This indicates gapsin CWEs or issues with the CWE assignments. In any case, we would need different methods to identify andspecify CVEs related to these operations."
"Labeling Software Security Vulnerabilities- Labeling Memory-Related CVEs via BF SpecificationsExamining further this subset of CVEs, we confirm that, overall the memory-related CWE to CVEassignments, which reflect the main weakness underlying each CVE are almost completely correct by BFoperation. For example, the CVEs mapped to CWE126 and CWE-788 correctly distinguish between the Read only and Read/Write operations, respectively. We only sporadically find examples of incorrect CWE to CVE assignments by operation, such as CWE-123 to CVE-2018-12036. The confusion for this CVE must relate to the use of ""writes"" in its description, while in fact it is a BF Input/Output Check (_INP) class type vulnerability: (Missing Code, Validate, File Injection)."
"Labeling Software Security Vulnerabilities- Labeling Memory-Related CVEs via BF SpecificationsHowever, when examining the CVEs by the CWE BF weaknesses of or chains of weaknesses, whichcover not only operations but also causes and consequences, we find parts of these BF weaknessspecifications may not fit all of the corresponding CVEs. For example, the BF CWE-126 chain completely fits the (Over Bounds Pointer, Read, Buffer Over-Read) main weakness of CVEs such as CVE-2014-0160 (Heartbleed), as well as their (Wrong Index, Reposition, Over Bounds Pointer) direct causing weakness. However, most of the CVEs with CWE-126 assigned have as an initial weakness Missing Code for a Verify operation and not Erroneous Code in a Calculate operation. This can be explained by CWE's lack of flexibility to describe all possible security weaknesses- the entries could be too specific to be reused, some may be missing, and some may be overlapping. We will have to use entirely different methods to identify and specify the parts of the BF description for a CVE that do not fit the overly specific CWE variation assigned to that CVE."
"Labeling Software Security Vulnerabilities- Labeling Memory-Related CVEs via BF SpecificationsWe find also that from the CWEs with different BF specifications CWE-586 and CWE-568are not assigned to any CVE. Then, from the CWE groups with identical BF specifications,the following CWEs were not assigned to any CVE at all: CWE 806 from the 805, 806 pair, CWE 1341 fromthe 415, 1341 pair, CWE 463 and CWE 464 from the 170, 463, 464 triple, and CWE 224, CWE 1239, andCWE 1272 from the 226, 224, 1239, 1272 quadruple. It is interesting to explore if there are CVEs that arebetter described by the unused CWEs. One such example is CVE-2023-38434 (although outside of our 91 CVEs set) that describes a double free when closing a web connection. NVD assigns it CWE-415 (Double Free) of a memory resource, instead of the more general CWE1341 (Multiple Releases of Same Resource or Handle). These two CWEs share the (Erroneous Code, Deallocate, Double Free) BF weakness triple; their similarity and the vague memory versus resource distinction introduces errors and ambiguities in CWE-CVE assignments that would also affect our efforts for CVE labeling."
"Labeling Software Security Vulnerabilities- Labeling Memory-Related CVEs via BF SpecificationsThe rest of the similar CWEs lead in many cases to ambiguous CWE-CVE assignments. One such example is CVE-2022-0519, which describes a buffer access with an incorrect length value leading to a buffer over-read. NVD assigns this CVE to CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer) and CWE-805 (Buffer Access with Incorrect Length Value). However, CWE126 (Buffer Over-Read) also nicely and more accurately describes this CVE than the abstract CWE-119."
"Labeling Software Security Vulnerabilities- Labeling Memory-Related CVEs via BF SpecificationsAnother area of ambiguity among CWEs relates to BF attributes. For example, CVE-2023-40295describes a buffer overflow on the heap. NVD assigns CWE-787 (Out of Bounds Write) to this CVE, whichaccurately describes the vulnerability. However, CWE122 is also a suitable assignment, as it describesbuffer overflow specifically on the heap. Apart from this minor difference (captured in BF by an address-related attribute), CWE-122 and CWE-787 share an identical main weakness: (Over Bounds Pointer/UnderBounds Pointer, Write, Buffer Overflow, Buffer Underflow). While CWE-122 is the more specific mapping, the similarities create difficulty in deciding which CWE should be assigned to this CVE."
"Labeling Software Security Vulnerabilities- Labeling Memory-Related CVEs via BF SpecificationsIn many cases, CWE-CVE assignments capture either the cause of a vulnerability or its consequencebut not both. CVE-2022-34399 and CVE 2022- 32454 describe a buffer over-read and a buffer over-write vulnerability, respectively. The BF chain for CVE-2022-34399 is (Missing Code, Verify, Inconsistent Value) to (Wrong Index, Reposition, Over Bounds Pointer) to (Over Bounds Pointer, MUS Write, Buffer Overflow), and the BF chain for CVE-2022- 32454 is (Missing Code, Verify, Wrong Value) to (Wrong Size, MUS Read, Buffer Over-Read). NVD assigns CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer) and CWE-805 (Buffer Access with Incorrect Length Value) to CVE 2022-34399 and CWE-121 (Stack-based Buffer Overflow) to CVE 2022-32454. However, the CWEs assigned to CVE 2022-34399 only describe the cause of the vulnerability, and the CWE assigned to CVE 2022-32454 only describes its consequence. One must assign CWE-126 (Buffer Over-Read) to CVE 2022-34399 and CWE-112 (Missing XML Validation) to capture the full story of each weakness underlying the vulnerability. This inconsistency in capturing either the cause or the consequence of a vulnerability further complicates the CWE-CVE assignment."
"Labeling Software Security Vulnerabilities- Labeling Memory-Related CVEs via BF SpecificationsThe findings from this work show areas that would require additional analysis to create precise BF CVEdescriptions. We would have to examine deeply corresponding vulnerability reports, source code with bugs,source code with fixes, and other available related resources. Utilizing the BF vulnerability model, theBF cybersecurity concepts definitions and BF taxons definitions, as well as any of their synonyms in use, we can employ modern ML and AI approaches toward automatic CVEs analysis and generation of BF CVE specifications."
"Labeling Software Security Vulnerabilities- ConclusionLabeled vulnerability descriptions are of great demand for advanced AI research related to cybersecurity vulnerabilities, attacks, and mitigation techniques. As a formal bugs/weaknesses model, BF has the ability to unambiguously describe the chains of underlying weaknesses for any software security vulnerability."
Labeling Software Security Vulnerabilities- ConclusionWith this work we begin specifying the detailed information provided for each CWE. We use the CWEsas a bridge to the corresponding CVEs and explore to what extent the BF CWE descriptions may aid manualcreation of BF CVE descriptions.
"Labeling Software Security Vulnerabilities- ConclusionOur future goal is to employ ML and AI approaches for automated generation of BF CVE descriptions.The result would be a reference dataset of labeled vulnerability specifications for use by AI algorithms.The labels will constitute the exhaustive sets of causes, operations, consequences, and attributes values, precisely defined as BF class taxonomies. The BF CVE reference dataset will be a great source not onlyfor research but also for cybersecurity education and guidance."
